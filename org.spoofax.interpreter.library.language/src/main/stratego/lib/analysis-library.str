module lib/analysis-library
 
imports
  libstratego-lib
  libstratego-parallel
  lib/editor-common.generated
  lib/index-library
 
signature constructors
 
  // Analyze constructors
  Results     : AST * List(Def) * List(Use) * List(DefData) * List(Def) * List(Def) * List(File) -> Results
  Editor      : AnalysisPhase
  Compile     : AnalysisPhase
 
  // Index elements
  Def          : List(UriPart) -> Summary
  Use          : List(UriPart) -> Summary
  BadUse       : List(UriPart) -> Summary
  Read         : List(UriPart) -> Summary
  ReadWildcard : List(UriPart) * String -> Summary
  Diff         : List(UriPart) * List(Summary) -> Summary
    
  // Namespaces
  Diff         : Namespace
  ASTDiff      : Namespace
  
  // Adjust lookup actions
  StopLookup   : LookupAction
  
  // Parallel
  ParallelResults : AST * AST * List(Error) * List(Warning) * List(Note) * List(File) -> ParallelResults
  
rules // Index analysis extension points
 
  /**
   * Extension point. Override this rule to adjust how the index analysis looks up use sites to definitions.
   *
   * The overriden rule must return a list that contains any of the following items:
   *   - Def(uri)         : A definition with exactly this URI has been found. This tells the lookup to resolve the
   *                        use site to this definition.
   *   - [namespace|path] : This tells the lookup to do a new lookup at the given namespace and path.
   * 
   * Returning multiple of these in the list is allowed, these will all show up during content completion and possibly
   * other custom strategies. If multiple items are returned during reference resolving for example, the first item
   * will be used.
   *
   * If the lookup has failed, for example your custom rule cannot find any definitions, you can also return 
   * StopLookup() instead of a list. This tells the lookup algorithm to stop any further lookups for this use site.
   * This can be useful to stop lookups for recursive expressions like property access, preventing a lot of useless
   * lookups that will always fail anyway.
   *
   * Extension example:
   *   adjust-index-lookup(check-target-name|namespace, path, prefix):
   *     PropAccess(exp, name) -> properties
   *     where
   *       <check-target-name> name
   *     with
   *       if TYPE(type{_}) := <type-of> exp then
   *         properties := <index-lookup-children(|Property(), prefix)> type
   *       else
   *         properties := StopLookup()
   *       end
   *
   *   adjust-index-lookup(check-target-name|namespace, path, prefix):
   *     Var(name) -> [[Var() | path], [Property() | path]]
   *     where
   *       <check-target-name> name
   *
   * @param check-target-name   A strategy that should be used to check if the name of the current element is what the
   *                            lookup algorithm is looking for.
   * @param namespace           The namespace of the element that should be looked up.
   * @param path                The path the lookup algorithm is currently looking at for the element.
   * @param prefix              The prefix name of the element the lookup algorithm is looking for. This is usually the
   *                            full name of the element, but could be a partial prefix during content completion.
   */
  adjust-index-lookup(check-target-name|namespace, path, prefix) = fail
  
  /** 
   * Extension point. Override this rule to store data about definitions in the index. Should call <store-results> on 
   * a (list of) data that must be stored in the index.
   *
   * Note that store-results always fails, this is a trick to make every adjust-index-def-data override always fail so 
   * that every overriden rule is called once for each definition. This can lead to unexpected behaviour when trying to 
   * store multiple items by calling store-results in a map or filter! Be sure to always let your adjust-index-def-data 
   * rule fail if you are doing a <filter(store-results)> for example.
   *
   * Extension example:
   *   adjust-index-def-data(store-results|namespace, path):
   *     def -> <store-results> Type([namespace|path], type)
   *     where
   *       type := <type-of> def
   *
   * @param store-results Call this on the data you want to store in the index.
   * @param namespace     The namespace of the definition that the rule is being called on.
   * @param path          The path of the definition that the rule is being called on.
   */
  adjust-index-def-data(store-results|namespace, path) = fail
  
  /**
   * Extension point. Override this rule to adjust how the index assigns a namespace and path (URI) to definitions and
   * use sites. Should return a path that will be assigned to the definition or use site.
   *
   * Extension example:
   *   adjust-index-path(check-target-definition|namespace, path):
   *     Start(_, _) -> [<string-replace(|<project-path>, "")> <Fst> <index-get-current-file>]
   *
   *
   * @param check-target-definition 
   * @param namespace               The namespace that would be given to the current definition or use site.
   * @param path                    The path that would be given to the current definition or use site.
   */
  adjust-index-path(check-target-definition|namespace, path) = fail
  
  /**
   * Extension point. Override this rule to define index-stored constructors to check for difference during analysis.
   * The index-diff-compare extension point is used to do the actual comparison. Defaults to Def constructs.
   *
   * Extension example:
   *   index-diff-constructors = ?Type(_, _)
   *
   * @see index-diff-compare
   */
  index-diff-constructors = 
    ?Def(_)
  
  /**
   * Extension point. Override this rule to define a custom comparison of two index elements. It should fail if they 
   * are not equal and return the indentity if they are equal. Only constructors defined by index-diff-constructors are
   * compared.
   *
   * Extension example:
   *   index-diff-compare:
   *     (Type(u1, v1), Type(u2, v2)) -> <id>
   *     where
   *       <index-uri-eq> (u1, u2);
   *       <eq> (v1, v2)
   *
   * @see index-diff-constructors
   */
  index-diff-compare:
    (Def(u1), Def(u2)) -> <id>
    where
       <index-uri-eq> (u1, u2)
 
rules // Analysis traversals
  
  /**
   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
   * Defaults to Editor() phase.
   *
   * @param language  The name of the language that is being analysed.
   *
   * @see analyze-top(|phase, language)
   */
  analyze-top(|language):
    (ast, path, project-path) -> <analyze-top(|Editor(), language, path, project-path)> ast
   
  /**
   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
   *
   * @param phase         The type of analysis phase. There are 2 phases to choose from:
   *                      - Editor():   File dependencies are analysed.
   *                      - Compile():  File dependencies are not analysed.
   * @param language      The name of the language that is being analysed.
   * @param path          The path of the file to analyze relative to project-path.
   * @param project-path  The path of the directory that contains all the source files.
   *
   * @see analyze-top-internal(|phase, language, project-path, full-path)
   */
  analyze-top(|phase, language, path, project-path):
    ast -> (ast', filesToAnalyze)
    with
      full-path := $[[project-path]/[path]];
      if index-split then
        index-setup(|language, [project-path], full-path); // Set up the index, splitting may require index calls.
        asts := <index-toplevel-split> ast;
        astsFilePairs := <map(ast-uri-to-ast-file(|full-path))> asts;
        Results(ast', _, _, _, _, _, filesToAnalyze) := 
          <analyze-top-internal(|phase, language, project-path, full-path)> astsFilePairs
      else
        Results(ast', _, _, _, _, _, filesToAnalyze) := 
          <analyze-top-internal(|phase, language, project-path, full-path)> [(ast, full-path)]
      end
  
  /**
   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
   *
   * @internal
   */
  analyze-top-internal(|phase, language, project-path, full-path):
    astFilePairs -> Results(asts, defs, uses, data, added, removed, filesToAnalyze)
    with
      // Init
      index-setup(|language, [project-path], full-path);
      revision := <index-start-transaction>
    with
      // Store old elements
      oldElems := <filter(index-diff-constructors)> <index-get-all-in-file> full-path;
      <index-clear-file> full-path
    with
      {| Index-UnresolvedSet:
        unresolvedSet := <new-iset>;
        rules(Index-UnresolvedSet: _ -> unresolvedSet);
        
        (astFilePairs2, defsList) := <unzip> <map(analyze-top-defs)> astFilePairs;
        defs := <concat> defsList;
        (astFilePairs3, dataList) := <unzip> <map(analyze-top-data(|language, full-path))> astFilePairs2;
        data := <concat> dataList;
        (astFilePairs4, usesList) := <unzip> <map(analyze-top-uses(|language, full-path))> astFilePairs3;
        uses := <concat> usesList;
        (asts, _) := <unzip> astFilePairs4
      |}
    with
      index-end-transaction
    with
      // Schedule re-analysis of dependent files (if current file is not testing language file)
      // HACK: Depends on file extension, could be other languages with .spt extension?
      if Editor() := phase; not(<is-test-file> full-path) then
        newElems := <conc> (defs, <filter(index-diff-constructors)> data);
        
        // Find added and removed definitions
        (added, removed) := <analyze-diff> (oldElems, newElems);
        changed := <conc> (added, removed);
        
        // Store files that have changed in the index
        index-transaction(
          filesToAnalyze := <analyze-store-diff(|changed, revision)> astFilePairs4
        )
      else
        (added, removed) := ([], []);
        filesToAnalyze := []
      end
    with
      <list-loop(analyze-top-store-ast)> astFilePairs4
      
  /**
   * Add URI annotations to each definition and unresolved URI annotations to each use site.
   *
   * @internal
   */
  analyze-top-defs:
    (ast, file) -> ((ast2, file), defs)
    with
      <index-set-current-file> file;
      (Some(ast2), defs) := <analyze-defs> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
      <index-add-all(|file)> defs
      
  /**
   * Gathers all data for each definition.
   *
   * @internal
   */
  analyze-top-data(|language, full-path):
    (ast, file) -> ((ast2, file), data2)
    with
      <index-set-current-file> file;
      {| Index-ReadSet:
        readSet := <new-iset>;
        rules(Index-ReadSet: _ -> readSet);
        
        // Gather all data for each definition.
        ast2 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast; // Parent pointers needed.
        data := <origin-track-forced(analyze-tree-data)> ast2;
        
        // Resolve all references in gathered data.
        (data2, _) := <analyze-uses> data; // Ignoring data uses, have not found a use-case for them yet.
        <index-add-all(|file)> data2;
        
        // Store reads into the index (if not testing language)
        if not(is-test-input(|language, full-path)) then
          <index-add-all(|file)> <iset-elements> readSet
        end
      |}
      
  /**
   * Resolves all unresolved references for each use site.
   *
   * @internal
   */
  analyze-top-uses(|language, full-path):
    (ast, file) -> ((ast3, file), uses)
    with
      <index-set-current-file> file;
      {| Index-ReadSet:
        readSet := <new-iset>;
        rules(Index-ReadSet: _ -> readSet);
        
        // Resolve all unresolved references for each use site.
        (ast2, uses) := <analyze-uses> ast;
        <index-add-all(|file)> uses;
        
        ast3 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast2; // AST changed, reset parent pointers.
        
        // Store reads into the index (if not testing language)
        if not(is-test-input(|language, full-path)) then
          <index-add-all(|file)> <iset-elements> readSet
        end
      |}
      
  /**
   * Stores AST from file to the index.
   *
   * @internal
   */   
  analyze-top-store-ast:
    (ast, file) -> <id>
    with
      <index-set-global(|[<index-file-to-string> file, "ast"])> ast
      
  /**
   * Identifies all definitions in the tree and annotates them with their URI.
   * Also annotates uses with a preliminary "Unresolved(_)" URI.
   *
   * @internal
   */
  analyze-defs = analyze-defs(|Anon(), Anon())
  /** @internal */
  analyze-defs(|head-scope, head-scope-ns):
    ast -> (ast', defs')
    with
      if def := <nam-get-definition> ast then
        Def(def-path)                     := def;
        [head-scope-ns', head-scope' | _] := def-path
      else
        def-path       := INTERNAL_ERROR();
        head-scope-ns' := head-scope-ns;
        head-scope'    := head-scope
      end;
      if scope-types := <nam-get-scope-types> ast then
        {| IndexPath:
          <list-loop(update-index-path(|head-scope', head-scope-ns', ast))> scope-types;
          // <balanced-update-path> head-scope';
          (ast', defs) := <analyze-defs-recurse(|Anon(), Anon(), def-path)> ast
        |}
      else
        (ast', defs) := <analyze-defs-recurse(|head-scope', head-scope-ns', def-path)> ast
      end;
      defs' := <![def | defs] <+ !defs>
      
  /** @internal */
  analyze-defs-recurse(|head-scope, head-scope-ns, def-path):
    ast -> (ast'', defs)
    where
      analyzed      := <all(analyze-defs(|head-scope, head-scope-ns))> ast;
      (ast', defs)  := <unzip-analyzed> analyzed;
      ast''         := <try(nam-annotate-names(|def-path))> ast'
 
  /** @internal */
  update-index-path(|head-scope, head-scope-ns, ast):
    scope-type -> scope-type
    where
      if !head-scope-ns => Anon() then
        path  := <IndexPath <+ ![]> scope-type;
        path' := <do-adjusted-index-path(|scope-type, path, Anon(<new>))> ast
      else
        path  := <IndexPath <+ ![]> head-scope-ns;
        path' := <do-adjusted-index-path(|scope-type, path, head-scope)> ast
      end;
      rules(IndexPath: scope-type -> path')
 
  /* TODO: consider using simple-update-def-path
   *       which uses "balanced" path scopes
   *       e.g. when Entity doesn't scope Function
   *       then it's hard to access properties from a function
  balanced-update-index-path:
    head-scope -> head-scope
    where
      if !head-scope => Anon() then
        head-scope' := Anon(<new>)
      else
        head-scope' := head-scope
      end;
      (something with do-adjust-path)
      rules(IndexPath := [head-scope' | <IndexPath <+ ![]> ()])
  */
 
  /**
   * Analyze all uses, changing their preliminary "Unresolved(_)" URI to a definite URI of their definition.
   *
   * @internal
   */
  analyze-uses:
    ast -> (ast'', uses')
    with
      analyzed     := <all(analyze-uses)> ast;
      (ast', uses) := <unzip-analyzed> analyzed;
      if !ast' => _{unresolved@[Unresolved(namespace), x | path]} then
        if Def(def-uri) := <index-lookup(id |namespace, path, <strip-annos> ast')> ast' then
          ast'' := ast{def-uri};
          uses' := [Use(def-uri) | uses]
        else
          ast'' := ast';
          uses' := [BadUse([namespace, x]) | uses]
        end
      else
        ast'' := ast';
        uses' := uses
      end
 
  /**
   * Collects all index data (e.g. types of definitions).
   *
   * @internal
   */
  analyze-tree-data:
    tree -> data
    where
      set := <new-iset>;
      <topdown(analyze-tree-data-part(|set))> tree;
      data := <iset-elements> set
      
  /** @internal */
  analyze-tree-data-part(|set):
    tree -> tree
    where
      if def-term := <nam-get-definition-key> then
        _{[namespace | path]} := def-term;
        if result := <adjust-index-def-data(store-index-data-results(|set) |namespace, path)> tree then
          <fatal-err(|"Unexpected result from adjust-index-def-data; should call <store-results>")> result
        end
      end
  
  /** @internal */
  store-index-data-results(|set):
    t -> <fail>
    where
      if is-list then
        <iset-addlist(|t)> set
      else
        <iset-add(|t)> set
      end
  
rules // Parallel analysis
  
  /**
   * Does a parallel analysis of given files using the specified analysis strategy. Automatically does parallel
   * analysis of dependent files that have changed during the analysis.
   *
   * Example:
   *   <index-parallel-analyze-files(analyze)> ["text/file1.ext", "text/file2.ext"]
   *
   * @param analyze (ast, path, project-path) -> (ast', errors, warnings, notes, filesToAnalyze). Strategy that 
   *                analyzes a file using the index. Gets a (ast, path, project-path) tuple as input and must return 
   *                a (ast', errors, warnings, notes, filesToAnalyze) tuple as output.
   */
  index-parallel-analyze-files(analyze):
    files -> None()
    with
      length; 
      set-total-work-units
    with
      index-parallel-analyze(analyze);
      filter(not(?ParallelResults((), (), _, _, _, _) <+ ?ParallelResults((), [()], _, _, _, _)); index-set-markers)
  
  /** @internal */
  index-parallel-analyze(analyze):
    files -> allResults
    with
      map(index-parse-file); // Parsing cannot be done in parallel.
      map(\(ast, file) -> (ast, file, <project-path>)\);
      parallel-unordered(all(index-analyze(analyze)));
      ?results;
      with(<eq> (<length> results, <length> files) | "Input size not equal to output size");
      filesToAnalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
      if not([] := filesToAnalyze) then
        allResults := <concat> [results, <index-parallel-analyze(analyze)> filesToAnalyze]
      else
        allResults := results
      end
  
  /** @internal */   
  index-parse-file:
    file -> (ast, file)
    with
    if <file-exists> file then
      ast := <parse-file> file
    else
      ast := ()
    end
   
  /** @internal */   
  index-set-markers:
    ParallelResults(ast, ast', errors, warnings, notes, diffs) -> <id>
    with
      <set-markers(|ast)> (ast', errors, warnings, notes)
      
  /** @internal */
  index-analyze(analyze):
    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, filesToAnalyze)
    with
      (ast', errors, warnings, notes, filesToAnalyze) := <analyze>;
      if [] := filesToAnalyze then
        complete-work-unit
      end
      
/** @internal */
rules // Splitter
  
  /** @internal */
  index-split = fail
  /** @internal */
  index-is-toplevel = fail
  /** @internal */
  index-is-qualifier = fail
  /** @internal */
  index-qualifier-subelements = fail
  /** @internal */
  index-create-qualifier(|qualifier) = fail
  
  /** @internal */
  index-toplevel-split:
    ast -> asts'
    with
      (ast', _) := <analyze-defs> ast;
      asts      := <index-toplevel-split-internal> ast';
      asts'     := <strip-annos> asts
      
  /** @internal */
  index-toplevel-split-internal:
    node -> units
    with
      switch id
        case ?():
          units := [((), [])]
        case index-is-qualifier:
          elems := <mapconcat(index-toplevel-split-internal)> <index-qualifier-subelements> node;
          units := <map(index-transform-qualifier(|node))> elems
        case index-is-toplevel:
          units := [(node, <index-uri> <nam-get-definition-key> node)]
        otherwise:
          units := [(node, [])]
      end
      
  /** @internal */
  index-transform-qualifier(|node):
    (elem, subfileName) -> (qualifier, subfileName)
    with
      qualifier := <index-create-qualifier(|node)> elem

/** @internal */
rules // Diffs
  
  /** @internal */
  analyze-diff:
    (defs1, defs2) -> (added, removed)
    with
      added   := <diff(index-diff-compare)> (defs2, defs1);
      removed := <diff(index-diff-compare)> (defs1, defs2)
    
  /** @internal */
  analyze-store-diff(|changedEntries, revision): 
    astFilePairs -> analyzeFiles'
    with
      changedFiles    := <mapconcat(index-get-files-of)> changedEntries;
      dependentFiles  := <index-get-dependent-files> changedEntries;
      
      // Files to analyze
      analyzeFiles := <make-set> <remove-all(fake-file)> dependentFiles;
      analyzeFiles' := analyzeFiles;
      // TODO: Is this extra check needed?
      /*if <getfirst(index-get-file-revision; \r -> (r, revision)\; gt)> analyzeFiles then
        // Add current file if the current file has read information from another file with a higher revision.
        // This indicates that potentially outdated information was read.
        analyzeFiles' := [file|analyzeFiles]
      else
        analyzeFiles' := analyzeFiles
      end;*/
      
      // Files to compile
      changedAstFiles := <filter(analyze-astdiff)> astFilePairs;
      compileFiles := <make-set> <concat> [analyzeFiles', changedFiles, changedAstFiles];
      // TODO: Optimize so that there are no duplicate files stored in the index, use iset?
      <map(analyze-add-compilediff)> compileFiles
      
  /** 
   * Checks if ast for given file has changed. Succeeds if old ASTDiff is not found or if ASTDiff is different.
   *
   * @internal
   */
  analyze-astdiff:
    (ast, file) -> file
    where
      name := [<index-file-to-string> file, "ast-checksum"];
      newChecksum := <checksum> ast;
      if oldChecksum := <index-get-global(|name)> then
        <index-set-global(|name)> newChecksum;
        not(<eq> (oldChecksum, newChecksum))
      else
        <index-set-global(|name)> newChecksum
      end
      
  /** 
   * Adds given file to the list of files to compile.
   *
   * @internal
   */
  analyze-add-compilediff = index-add-global(|"compile-diff")
  
  /** 
   * Gets the list of files to compile, and then clear it.
   *
   * @internal
   */
  analyze-get-compilediffs = index-get-all-globals(|"compile-diff"); index-clear-global(|"compile-diff")
 
rules // index API query primitives
 
  /**
   * Gets all DefData entries that match the kind of data and URI in given definition.
   *
   * Example:
   *   <index-get-data(|Type())> Def([Entity(), "Bar"]) => [DefData([Entity(), "Bar"], Type(), TYPE("Bar")), ...]
   *
   * @param kind Only data of this kind is returned.
   */
  index-get-data(|kind):
    <with(?Def(uri) | "Def expected")> -> <index-get-value> DefData(uri, kind, ())
      
  /**
   * Gets all data entries that match the kind of data and URI in given definition.
   *
   * Example:
   *   <index-get-data-all(|Type())> Def([Entity(), "Bar"]) => [TYPE("Bar"), ...]
   *
   * @param kind Only data of this kind is returned.
   */
  index-get-data-all(|kind):
    <with(?Def(uri) | "Def expected")> -> <index-get-all-values> DefData(uri, kind, ())
     
  /**
   * Gets all Use entries that match the URI in given definition.
   *
   * Example:
   *   <index-get-uses-all> Def([Entity(), "M", "Bar"]) => [Use([Entity(), "M", "Bar"]), ...]
   */
  index-get-uses-all:
    <with(?Def(uri) | "Def expected")> -> <index-get-all> Use(uri)
     
  /**
   * Gets all Read or ReadWildcard entries that match the given template.
   *
   * Example:
   *   <index-get-reads-all> [Property(), "Bar", "p"] => [Read([Property(), "Bar", "p"]), ...]
   */
  index-get-reads-all:
    template -> <conc> (reads, readwildcards')
    where
      uri   := <index-uri> template;
      reads := <index-get-all> Read(uri);
      if !uri => [namespace, prefix | path-parent] then
        readwildcards  := <index-get-all> ReadWildcard([namespace | path-parent], ());
        readwildcards' := <filter(index-readwildcard-substring(|prefix))> readwildcards
      else
        readwildcards' := []
      end
 
  /**
   * Get all index entries that match the given template.
   *
   * Example:
   *   <index-get-all> Def([Entity(), "Bar"]) => [Def([Entity(), "Bar"]), ...]
   */
  index-get-all:
    template -> <indexlib-get-all> template
      with
       if set := <Index-ReadSet> then
         uri := <index-uri>;
         <iset-add(|Read(uri))> set
       end
       
  /**
   * Get all values of index entries that match the given template.
   *
   * Example:
   *   <index-get-all-values> DefData([Property(), "s"], Type(), ()) => [TYPE("String"), ...]
   *
   * @see index-value
   */
  index-get-all-values:
    template -> <map(index-value)> <index-get-all> template
       
  /**
   * Get the first index entry that matches the given template, or fail.
   *
   * Example:
   *   <index-get> Def([Entity(), "Bar"]) => Def([Entity(), "Bar"])
   */
  index-get:
    template -> <?[<id>|_]> <index-get-all> template
      
  /**
   * Get the value of first index entry that matches the given template, or fail.
   *
   * Example:
   *   <index-get-value> DefData([Entity(), "Bar"], Type(), ()) => TYPE("Bar")
   *
   * @see index-value
   */
  index-get-value:
    template -> <index-value> <?[<id>|_]> <index-get-all> template

  /**
   * Gets all Def children elements of an URI in a certain namespace.
   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
   *
   * Example:
   *   <index-get-children(|Field())> Def([Entity(), "Baz"]) => [Def([Field(), "Bar"]), Def([Field(), "Foo"]), ...]
   *   <index-get-children(|Field())> "Foo"{[Entity(), "Baz"]} => [Def([Field(), "Bar"]), Def([Field(), "Foo"]), ...]
   *   <index-get-children(|Field())> [Entity(), "Baz"] => [Def([Field(), "Bar"]), Def([Field(), "Foo"]), ...]
   *
   * @param namespace Only child Def elements in this namespace are returned.
   */
  index-get-children(|namespace) = 
    index-get-children(\uri -> Def(uri)\|namespace)
  
  /**
   * Gets all children elements of an URI in a certain namespace using custom templates.
   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
   *
   * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
   * @param namespace           Only child elements in this namespace are returned.
   */
  index-get-children(construct-template|namespace):
    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children
    with
      template  := <construct-template> [namespace | path];
      children  := <prim("LANG_index_get_children", template)>;
      <store-wildcard-read(|namespace, path, "")> children

  /**
   * Gets all Def children elements of an URI in a certain namespace where the name starts with a prefix.
   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
   *
   * Example:
   *   <index-get-children(|Field(), "fo")> Def([Entity(), "Baz"]) => [Def([Field(), "Foo"]), ...]
   *   <index-get-children(|Field(), "ba")> "Foo"{[Entity(), "Baz"]} => [Def([Field(), "Bar"]), ...]
   *   <index-get-children(|Field(), "ze")> [Entity(), "Baz"] => [...]
   *
   * @param namespace Only child Def elements in this namespace are returned.
   * @param prefix    Only child Def elements where the name starts with this prefix are returned.
   */
  index-get-children(|namespace, prefix) = 
    index-get-children(\uri -> Def(uri)\|namespace, prefix)
  
  /**
   * Gets all children elements of an URI in a certain namespace where the name starts with a prefix
   * using custom templates.
   * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
   *
   * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
   * @param namespace           Only child elements in this namespace are returned.
   * @param prefix              Only child elements where the name starts with this prefix are returned.
   */
  index-get-children(construct-template|namespace, prefix):
    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children'
    with
      prefix'   := <strip-annos> prefix;
      template  := <construct-template> [namespace | path];
      children  := <prim("LANG_index_get_children", template)>;
      children' := <filter(index-is-name-substring(|prefix'))> children;
      <store-wildcard-read(|namespace, path, prefix')> children'

  /**
   * Gets a set of all files that have a reference to the given index entries.
   *
   * Example:
   *   <index-get-referenced-files(\uri -> [Read(uri), Use(uri, [])]\)> [Def([Entity(), "Bar"]), ...] => 
   *     [("fullpath/otherfile.ext", "subfile"), ...]
   *
   * @param construct-from-uri  uri -> List(elements). Construction strategy that creates a list of reference 
   *                            constructs from all given entries, such as \uri -> [Read(uri), Use(uri, [])]\
   */
  index-get-referenced-files(construct-from-uri):
    entries -> files
    where
      uris        := <filter(index-uri)> entries;
      referenced  := <concat> <filter(construct-from-uri)> uris;
      files       := <iset-elements> <iset-addlist(|<mapconcat(index-get-files-of)> referenced)> <new-iset>
 
  /**
   * Convenience function for finding files with Read and Use dependencies to the given definitions.
   *
   * Example:
   *   <index-get-dependent-files> [Def([Entity(), "Bar"]), ...] => [("fullpath/otherfile.ext", "subfile"), ...]
   *
   * @see index-get-referenced-files(construct-from-uri)
   * @see index-file-dependent-construct
   */
  index-get-dependent-files = 
    index-get-referenced-files(index-file-dependent-construct)
     
rules // Index lookup rules (take into account adjust-index-lookup)
 
  /**
   * Given an annotated AST node, resolves it, returning its Def.
   */
  index-lookup:
    x{[namespace|path]} -> <index-lookup(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
 
  /**
   * Given an annotated AST node, resolves it, returning all its Defs.
   */
  index-lookup-all:
    x{[namespace|path]} -> <index-lookup-all(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
 
  /**
   * Given an annotated AST node, resolves it, returning all its Defs.
   *
   * @param prefix  Only Defs with a name that starts with this string are returned.
   *
   * @internal
   */
  index-lookup(is-adjust-lookup-enabled|namespace, path, prefix):
    x -> def
    where
      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
      if <?StopLookup()> candidates then
        fail
      else
        def        := <index-select(|namespace, path, x)>
      <+
        // TODO: optimize: try not to call do-adjust-index-lookup from here
        [_ | path'] := path;
        def         := <index-lookup(is-adjust-lookup-enabled|namespace, path', prefix)> x
      end

  /**
   * Given an annotated AST node, resolves it, returning all its Defs.
   *
   * @param prefix  Only Defs with a name that starts with this string are returned.
   *
   * @internal
   */
  index-lookup-all(is-adjust-lookup-enabled|namespace, path, prefix):
    x -> defs'
    where
      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
      defs       := <index-select-all(|namespace, path, x)>;
      // TODO: optimize: try not to call do-adjust-index-lookup from here
      if [_ | path'] := path then
        defs2 := <index-lookup-all(is-adjust-lookup-enabled|namespace, path', prefix)> x;
        defs' := <conc> (defs, defs2)
      else
        defs' := defs
      end
 
  /**
   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
   *
   * @param prefix  Only Defs with a name that starts with this string are returned.
   */
  index-lookup-outermost(|prefix):
    x{[namespace|path]} -> <index-lookup-outermost(id|<index-namespace-unwrap> namespace, path, prefix)>
 
  /**
   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
   *
   * @param prefix  Only Defs with a name that starts with this string are returned.
   *
   * @internal
   */
  index-lookup-outermost(is-adjust-lookup-enabled |namespace, path, prefix):
    x -> def
    where
      // TODO: optimize: just like index-lookup
      [_ | path'] := path;
      def         := <index-lookup-outermost(is-adjust-lookup-enabled |namespace, path', prefix)> x
    <+
      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
      def        := <index-select(|namespace, path, x)>
 
  /**
   * Given an annotated AST node, returns a Def that has the same parent URI.
   *
   * @param prefix  Only Defs with a name that starts with this string are returned.
   */
  index-lookup-one-level(|prefix):
    x{[namespace|path]} -> <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
 
  /**
   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
   *
   * @param namespace Only Defs with this namespace are returned.
   * @param prefix    Only Defs with a name that starts with this string are returned.
   *
   * @internal
   */
  index-lookup-one-level(is-adjusted-lookup-enabled|namespace, path, prefix):
    x{_} -> defs
    with
      is-adjusted-lookup-enabled;
      do-adjust-index-lookup(|namespace, path, x, prefix);
      if ?StopLookup() then
        defs := StopLookup()
      else
        mapconcat(\d@Def(p) -> [d]\
          <+ \[namespace' | path'] -> <index-lookup-one-level(fail |namespace', path', prefix)> x\
          <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
        ?defs
      end
    <+
      defs := <index-get-children(|namespace, prefix)> Def([namespace | path])
      
  /**
   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
   *
   * @param namespace Only Defs with this namespace are returned.
   * @param prefix    Only Defs with a name that starts with this string are returned.
   */
  index-lookup-all-levels(|prefix):
    x{[namespace|path]} -> <index-lookup-all-levels(id|<index-namespace-unwrap> namespace, path, prefix)>
 
  /**
   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
   *
   * @param prefix  Only Defs with a name that starts with this string are returned.
   *
   * @internal
   */
  index-lookup-all-levels(is-adjust-lookup-enabled |namespace, path, prefix):
    x{_} -> all-defs
    with
      is-adjust-lookup-enabled;
      do-adjust-index-lookup(|namespace, path, x, prefix);
      if ?StopLookup() then
        all-defs := []
      else
        mapconcat(\d@Def(p) -> [d]\
            <+ \[namespace' | path'] -> <index-lookup-all-levels(fail |namespace', path', prefix)> x\
            <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
        ?all-defs
      end
    <+
      one-level := <index-get-children(|namespace, prefix)> Def([namespace | path]);
      if [_ | path'] := path then
        all-defs := <concat> [one-level, <index-lookup-all-levels(fail |namespace, path', prefix)> x]
      else
        all-defs := one-level
      end
 
  /**
   * Given an annotated AST node, resolves it, and returns all child Defs of its definition.
   *
   * @param namespace Only child Defs with this namespace are returned.
   * @param prefix    Only Defs with a name that starts with this string are returned.
   */
  index-lookup-children(|namespace, prefix): // TODO: how does this compare w/ index-lookup-one-level?
    x{[ns | path]} -> defs
    with
      if !ns => Unresolved(_) then
        Def([_ | def-path]) := <index-lookup>;
        defs := <index-lookup-one-level(id|namespace, def-path, prefix)> x
      else
        defs := <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
      end
    <+
      defs := []
      
rules // Index utilities
  
  /**
   * Gets the namespace part of the URI for given key (term{uri} element).
   *
   * Example:
   *   <index-uri-namespace> "Bar"{[Entity(), "Bar", "Baz"]} => Entity() 
   */
  index-uri-namespace:
    x{[namespace|path]} -> <index-namespace-unwrap> namespace

  /**
   * Gets the path part of the URI for given key (term{uri} element). Resolves it if unresolved.
   *
   * Example:
   *   <index-uri-path> "Bar"{[Entity(), "Bar", "Baz"]} => ["Bar", "Baz"]
   */
  index-uri-path:
    x{[namespace|path]} -> path'
    where
      if !namespace => Unresolved(namespace) then
        Def(path') := <index-lookup>
      else
        path' := path
      end
      
  /**
   * Gets the name part of the URI for given key (term{uri} element).
   *
   * Example:
   *   <index-uri-name> "Bar"{[Entity(), "Bar", "Baz"] => "Bar"
   */ 
  index-uri-name:
    x{[_|[name|_]]} -> name
    
  /**
   * Tries to get the name part of the URI for given term or fail if given term does not have an URI or name.
   *
   * Example:
   *   <index-uri-name> Def([Entity(), "Bar", "Baz"]) => "Bar"
   *   <index-uri-name> Type("Foo") => fail
   *   <index-uri-name> Read([Entity()]) => fail
   */   
  index-uri-name:
    x -> <index-uri-name> <index-uri> x
    where
      not(<has-annos> x)
    
  /**
   * Determines if a given AST node is a definition site, according to the syntax.
   *
   * TODO: Does not work?
   */
  index-is-definition =
    where(nam-get-definition-key)
    
  /**
   * Checks if given keys (term{uri} elements) are equal. Discards unresolved URI's.
   *
   * Example:
   *   <index-key-eq> ("Bar"{[Entity(), "Bar"]}, "Bar"{[Unresolved(Entity()), "Bar"]}) => 
   *     ("Bar"{[Entity(), "Bar"]}, "Bar"{[Unresolved(Entity()), "Bar"]})
   *   <index-key-eq> ("Foo"{[Entity(), "Foo"]}, "Bar"{[Entity(), "Bar"]}) => fail
   */      
  index-key-eq:
    (k1, k2) -> <id>
    where
      <eq> (<index-key-unwrap> k1, <index-key-unwrap> k2)
       
/** @internal */
rules // URI and value projections
       
  /** @internal */
  index-uri-impl:
    Def(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    Use(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    Read(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    x{[namespace | path]} -> [<index-namespace-unwrap> namespace | path]
 
  /**
   * TODO: Should second part of ReadWildcard be included in the URI, between namespace and path?
   * 
   * @internal 
   */
  index-uri-impl:
    ReadWildcard(uri, _) -> uri

  /** @internal */
  index-value-impl:
    Def(value) -> value

  /** @internal */
  index-value-impl:
    Use(value) -> value

  /** @internal */
  index-value-impl:
    Read(value) -> value
  
  /** @internal */
  index-value-impl:
    ReadWildcard(_, value) -> value
       
/** @internal */
rules // Internal helpers

  /**
   * Transforms a term C( (a1, [b1]), (a2, [b2, b3]) ) to a tuple (C(a1, a2), [b1, b2, b3]).
   *
   * @internal
   */
  unzip-analyzed:
    appl -> (appl', unzipped-parts)
    with
      appl'          := <all(\(a, _) -> a\)> appl;
      unzipped-parts := <concat> <get-appl-arguments(\(_, b) -> b\) <+ map(\(_, b) -> b\) <+ ![]> appl
       
  /**
   * Tests if the current file is just a testing language input
   *
   * @internal
   */
  is-test-file = 
    string-ends-with(|".spt")
  /** @internal */
  is-test-language = 
    ?"Spoofax-Testing"
  /** @internal */
  is-test-input(|language, path) = 
    <is-test-language> language <+ <is-test-file> path
      
  /** @internal */
  fake-file = 
    is-test-file <+ index-is-fake-file
  
  /** @internal */    
  index-filepair-to-file = 
    Fst; string-replace(|$[[<project-path>]/], "")
  
  /** @internal */
  ast-uri-to-ast-file(|full-path):
    (ast, uri) -> (ast, (full-path, uriStr))
    with
      (<index-uri-to-string> uri <+ !"") => uriStr
  
  /** @internal */     
  index-is-name-substring(|name):
    template -> <id>
    with
      [_, uri-name | _] := <index-uri>
    where
      <is-substring(!name)> uri-name
   
  /** @internal */    
  index-readwildcard-substring(|prefix):
    ReadWildcard(_, name) -> <id>
    where <is-substring(!prefix)> name
  
  /** @internal */  
  store-wildcard-read(|namespace, path, prefix):
    children -> <id>
    with
      if set := <Index-ReadSet> then
        if 1 := <length> children then
          // HACK: This solves the problem of ReadWildcards making too many files re-analyze, but this should
          // be handled in the index primitives instead.
          <iset-add(|Read([namespace | path]))> set
        else
          <iset-add(|ReadWildcard([namespace | path], prefix))> set
        end
      end
  
  /** @internal */    
  index-is-unresolved(|x, uri) = 
    Index-UnresolvedSet; (iset-contains(|(x, uri)) <+ fail)
  /** @internal */
  index-add-unresolved(|x, uri) = 
    (Index-UnresolvedSet; iset-add(|(x, uri))) <+ id
  
  /** @internal */
  index-file-dependent-construct: 
    uri -> <conc> (uses, reads)
    with
      uses := <index-get-uses-all> Def(uri);
      reads := <index-get-reads-all> Def(uri)
  
  /** @internal */  
  index-file-dependency-filter = 
    ?Read(_) <+ ?ReadWildcard(_, _) <+ ?Use(_)
 
  /** @internal */
  do-adjust-index-lookup(|namespace, path, use, prefix) =
    repeat-until(
      prim("SSL_EXT_get_parent", <id>)
    , adjust-index-lookup(origin-equal(|use) |namespace, path, prefix) 
    )
 
  /** @internal */
  index-select(|namespace, path, use) =
    getfirst(
      where(
        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
      )
    )
 
  /** @internal */
  index-select-all(|namespace, path, use) =
    filter(
      where(
        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
      )
    )
 
  /** @internal */
  do-adjusted-index-path(|namespace, path, def) =
    adjust-index-path(origin-equal(|def) |namespace, path)
  <+
    ![def | path]
 
  /** @internal */
  index-eq(|namespace, expected) =
    where(
      ?Def([_, name | _]);
      <SRTS-EXT-eq-ignore-annos(|expected)> name
    )
  
  /** @internal */
  external SRTS-EXT-eq-ignore-annos(|t)
  
  /** @internal */
  index-key-unwrap = 
    \key{uri} -> key{<index-uri-unwrap> uri}\ <+ id

/** @internal */
rules // Interface for generated code
 
  /** @internal */
  nam-get-def(|namespace):
    x -> Def([namespace, x | <IndexPath <+ ![]> namespace])
  
  /** @internal */ 
  nam-annotate-use(|namespace):
    t -> t{[Unresolved(namespace), t | <IndexPath <+ ![]> namespace]}
  
  /** @internal */ 
  nam-get-scope-types = fail
  /** @internal */
  nam-get-definition = fail
  /** @internal */
  nam-get-definition-key = fail
  /** @internal */
  nam-annotate-names(|def-path) = fail
  