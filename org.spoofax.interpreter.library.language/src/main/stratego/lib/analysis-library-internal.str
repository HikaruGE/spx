module lib/analysis-library-internal
 
imports
  libstratego-lib
  libstratego-parallel
  lib/editor-common.generated
  lib/analysis-library
  lib/index-library

signature

  constructors // Data kinds stored in the index.

    Type            : DefDataKind
    Import          : DefDataKind
    TImport         : DefDataKind
    Unique          : DefDataKind
  
  constructors // Resolution kinds for use sites.

    Regular         : Namespace * Name                           -> ResolutionKind
    Regular         : Namespace * Name * Type                    -> ResolutionKind
    Child           : Namespace * Name * Namespace * Name        -> ResolutionKind
    Child           : Namespace * Name * Namespace * Name * Type -> ResolutionKind
    
  constructors // Annotations used in analysis.

    Scope           : Term -> Anno
  
  constructors // Results from analysis-top and index-parallel-analyze.
  
    Results         : AST * List(Def) * List(Use) * List(DefData) * List(Def) * List(Def) * List(File) -> Results
    ParallelResults : AST * AST * List(Error) * List(Warning) * List(Note) * List(File) -> ParallelResults
   
  constructors // Namespaces
    
    Diff            : Namespace
    ASTDiff         : Namespace
    AST             : Namespace
    
  constructors // AST storage
    
    AST             : List(UriPart) * AST -> AST
  
rules // Analysis traversals
  
  /**
   * Analyses given AST and annotates definition and use sites found in the AST with URIs.
   *
   * @internal
   * @type List((ast, (file, subfile))) -> Results(List(ast), List(def), List(use), List(data), List(addedElem), 
   *                                       List(removedElem), List(fileToAnalyze@(file, subfile))))
   */
  analyze-top-internal(|phase, language, project-path, full-path):
    astFilePairs -> Results(asts, defs, uses, data, added, removed, filesToAnalyze)
    with
      // Init
      index-setup(|language, [project-path], full-path);
      revision := <index-start-transaction>
    with
      // Store old elements
      oldElems := <filter(index-diff-constructors)> <index-get-all-in-file> full-path;
      <index-clear-file> full-path
    with
      {| Index-UnresolvedSet:
        unresolvedSet := <new-iset>;
        rules(Index-UnresolvedSet: _ -> unresolvedSet);
        
        (astFilePairs2, defsList) := <map(analyze-top-defs); unzip> astFilePairs;
        defs := <concat> defsList;
        (astFilePairs3, dataList) := <map(analyze-top-data(|language, full-path)); unzip> astFilePairs2;
        data := <concat> dataList;
        (astFilePairs4, usesList) := <map(analyze-top-uses(|language, full-path)); unzip> astFilePairs3;
        uses := <concat> usesList;
        (asts, _) := <unzip> astFilePairs4
      |}
    with
      index-end-transaction
    with
      // Schedule re-analysis of dependent files (if current file is not testing language file)
      // HACK: Depends on file extension, could be other languages with .spt extension?
      if Editor() := phase; not(<is-test-file> full-path) then
        newElems := <conc> (defs, <filter(index-diff-constructors)> data);
        
        // Find added and removed definitions
        (added, removed) := <analyze-diff> (oldElems, newElems);
        changed := <conc> (added, removed);
        
        // Store files that have changed in the index
        index-transaction(
          filesToAnalyze := <analyze-store-diff(|changed, revision)> astFilePairs4
        )
      else
        (added, removed) := ([], []);
        filesToAnalyze := []
      end
    with
      <list-loop(analyze-top-store-ast(|full-path))> astFilePairs4

rules  // Phase 1: scope analysis

  /**
   * Add URI annotations to each definition and unresolved annotations to each use site.
   *
   * @internal
   */
  analyze-top-defs:
    (ast, file) -> ((ast2, file), defs)
    with
      <index-set-current-file> file;
      (ast2, defs, data) := <analyze-defs> ast; 
      <index-add-all(|file)> defs;
      (data2, _) := <analyze-uses> data;
      <index-add-all(|file)> data2
  
  /**
   * Identifies all definitions in the tree and annotates them with their URI.
   * Also annotates uses with a preliminary "Unresolved(pathes)" annotation, 
   * where "pathes" maps relevant namespaces to their pathes.
   *
   * @internal
   */
  analyze-defs:
    ast -> (ast', defs, data) 
    with 
      def-set  := <new-iset>; 
      data-set := <new-iset>;
      ast'     := <analyze-defs(|[], Anon(<new>), def-set, data-set)> ast;
      defs     := <iset-elements; map(try(Snd))> def-set;
      data     := <iset-elements> data-set
     
  /**
   * Special case for tree nodes which are defined as scopes at parent nodes. 
   *
   * @internal 
   */
  analyze-defs(|paths, subsequent, defs, data):
    ast{a*} -> ast'
    where
      a'* := <split-fetch(?Scope(uri*)) ; conc> a*
    with
      updates := <map(!(<Hd>, <Tl;Tl>))> uri* ;
      paths'  := <update-index-paths(|updates)> paths ;
      ast'    := <analyze-defs(|paths', subsequent, defs, data)> ast{a'*}
       
  /**
   * Default case for all other tree nodes. 
   *
   * Uses the following rules generated from a NBL definition:
   *
   * nam-get-definitions: definition sites of the current node
   * nam-get-scope-types: namespaces scoped by the current node
   * nam-annotate-use   : use sites of the current node
   *
   * @internal 
   */
  analyze-defs(|paths, subsequent, defs, data):
    ast{a*} -> f#(children'){a*}
    where 
      not(<fetch(?Scope(_))> a*)
    with
      // check wether the current AST node scopes other definitions
      // scope*: list of scope information
      //
      // updates the pathes for scoped namespaces
      if scope* := <nam-get-scope-types> ast then
        update* := <map(construct-index-path(|paths, defs, ast))> scope*;
        paths'  := <update-index-paths(|update*)> paths
      else
        paths'  := paths
      end;
      // check wether the current AST node defines names
      // ast1 : AST node with annotated definition sites and scopes
      // def* : list of definition entries
      // imp* : list of import entries
      //
      // definitions are paired with unique identifier to keep duplicates
      if (ast', def*, imp*) := <nam-get-definitions(|paths, paths', subsequent)> ast then
        <iset-addlist(|<map(!(<new>, <id>))> def*)> defs;
        <iset-addlist(|imp*)> data
      else
        ast' := ast 
      end;
      // analyze children and annotate use sites afterwards
      f#(children) := ast';
      children'    := <origin-track-forced(analyze-child-defs(|paths', defs, data))> children
      
  /** @internal */
  analyze-child-defs(|paths, defs, data):
    [] -> []
    
  /** @internal */
  analyze-child-defs(|paths, defs, data):
    [d|ds] -> [d'|ds']
    with
      subsequent := Anon(<new>);
      d'         := <analyze-defs(|paths, subsequent, defs, data)> d ;
      if scopes := <nam-ordered-def> d then
        updates := <map(\scope -> (scope, [subsequent|<lookup-index-path> (scope, paths)])\)> scopes ; 
        paths'  := <update-index-paths(|updates)> paths 
      else
        paths' := paths
      end;
      ds'  := <analyze-child-defs(|paths', defs, data)> ds

rules // helper for phase 1
   
  /** @internal */
  construct-index-path(|paths, defs, ast):
    (ns, name, scope-type, unique) -> (scope-type, path'')
    with
      path  := <lookup-index-path> (ns, paths);
      path' := <index-do-adjust-path(|scope-type, path, name)> ast;
      if () := unique then
        path'' := path'
      else
        path'' := <index-do-adjust-path(|scope-type, path', unique)> ast;
        <iset-add(|DefData([scope-type| path'], Unique(), path''))> defs
      end
  
  update-import(|source, paths):
    namespace -> DefData([namespace | path], Import(), source)
    with
      path := <lookup-index-path> (namespace, paths)
      
  /** @internal */
  update-index-paths(|updates) = 
    remove-all({key: Fst => key; <fetch-elem(Fst => key)> updates}); 
    at-end(!updates)
  
  /** @internal */
  lookup-index-path = 
    lookup' <+ ![]
 
  /** 
   * Kept for backward compatibility.
   *
   * @internal 
   */
  index-do-adjust-path(|namespace, path, scope) =
    adjust-index-path(origin-equal(|scope)|namespace, path) <+ ![scope|path]

rules // interface to NBL generator for phase 1
  
  /** @internal */
  nam-get-definitions(|paths, paths', subsequent) 
    = fail

  /** 
   * Callback for nam-get-definitions
   *
   * @internal */ 
  nam-annotate-def(|uris):
    t{a*} -> t{uris, a*}
  
  /** 
   * Callback for nam-get-definitions
   *
   * @internal */ 
  nam-annotate-scope(|paths):
    t -> t{Scope(paths)}
  
  /** @internal */ 
  nam-get-scope-types 
     = fail
  
  /** @internal */
  nam-annotate-uses(|paths) 
     = fail
  
  /**
   * Callback for nam-get-definitions (imports) and nam-annotate-uses
   * 
   * @internal 
   */ 
  nam-annotate-use(|paths, namespace*):
    t{a*} -> t{Unresolved(<filter(nam-is-relevant(|namespace*))> paths), a*}
    
  nam-is-relevant(|namespace*):
    (ns, _) -> <id> where <fetch-elem(?ns)> namespace*
 
  /** @internal */ 
  nam-ordered-def 
     = fail

rules // Phase 2: type analysis of definition sites     

  /**
   * Gathers all data for each definition.
   *
   * @internal
   */
  analyze-top-data(|language, full-path):
    (ast, file) -> ((ast2, file), data2)
    with
      <index-set-current-file> file;
      {| Index-ReadSet:
        readSet := <new-iset>;
        rules(Index-ReadSet: _ -> readSet);
        
        // Gather all data for each definition.
        ast2 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast; // Parent pointers needed.
        data := <origin-track-forced(analyze-data)> ast2;
        
        // Resolve all references in gathered data.
        (data2, _) := <analyze-uses> data;
        <index-add-all(|file)> data2;   
        
        // Store reads into the index (if not testing language)
        if not(is-test-input(|language, full-path)) then
          <index-add-all(|file)> <iset-elements> readSet
        end
      |}

 /**
   * Collects all index data (e.g. types of definitions).
   *
   * @internal
   */
  analyze-data:
    ast -> types
    with
      set := <new-iset>;
      <topdown(try(analyze-type(|set)); analyze-data-part(|set))> ast;
      types := <iset-elements> set
      
  /** @internal */
  analyze-type(|set):
    ast -> ast
    where
      (_{uri}, type) := <nam-get-type> ast;
      <iset-add(|DefData(uri, Type(), type))> set
      
  /** @internal */
  analyze-data-part(|set):
    ast -> ast
    where
      if keys := <nam-get-definition-keys> then
        <list-loop(do-adjust-index-def-data(|set, ast))> keys
      end

rules // helper for phase 2
   
  /**
   * Kept for backward compability and possibly additional data.
   * 
   * @internal 
   */
  do-adjust-index-def-data(|set, ast):
    key -> key
    where
      if 
        _{[ns|path]} := key; 
        result       := <adjust-index-def-data(store-index-data-results(|set) |ns, path)> ast 
      then
         <fatal-err(|"Unexpected result from adjust-index-def-data; should call <store-results>")> result
      end
  
  /** @internal */
  store-index-data-results(|set):
    t -> <fail>
    where
      if is-list then
        <iset-addlist(|t)> set
      else
        <iset-add(|t)> set
      end

rules // interface to NBL generator for phase 2
  
  /** @internal */
  nam-get-definition-keys
    = fail

  /** @internal */
  nam-get-type
    = fail

rules // Phase 3: resolution of use sites     

  /**
   * Resolves all unresolved references for each use site.
   *
   * @internal
   */
  analyze-top-uses(|language, full-path):
    (ast, file) -> ((ast3, file), uses)
    with
      <index-set-current-file> file;
      {| Index-ReadSet:
        readSet := <new-iset>;
        rules(Index-ReadSet: _ -> readSet);
        
        // Resolve all unresolved references for each use site.
        (ast2, uses) := <analyze-uses> ast;
        <index-add-all(|file)> uses;
        
        ast3 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast2; // AST changed, reset parent pointers.
        
        // Store reads into the index (if not testing language)
        if not(is-test-input(|language, full-path)) then
          <index-add-all(|file)> <iset-elements> readSet
        end
      |}

  /**
   * Analyze all uses, changing their preliminary "Unresolved(_)" annotation 
   * to an URI of their definition.
   *
   * @internal
   */
  analyze-uses:
    ast -> (ast', uses)
    with
      use-set := <new-iset>;
      ast'    := <bottomup(try(analyze-use(|use-set)))> ast;
      uses    := <iset-elements ; map(Snd)> use-set
  
  analyze-use(|uses):
    ast -> ast'
    where
      _{Unresolved(paths)} := ast;
      origin               := <origin-term> ast;
      resolution*          := <repeat-until(prim("SSL_EXT_get_parent", <id>), nam-resolve(origin-equal(|ast)))> origin;
      if 
        COMPLETION(_) := ast 
      then
        ast' := ast{<filter(index-complete(|paths, ast)); concat> resolution*}
      else
        Def(def-uri) := <fetch-elem(index-resolve(|paths, ast))> resolution*;
        ast'         := ast{def-uri};
        <iset-add(|(<new>, Use(def-uri)))> uses
      end

rules // resolution rules for phase 3
  
  index-resolve(|paths, target):
    Regular(ns, name) -> <index-lookup-name> (ns, name', path)
    where
      name' := <strip-annos> name;
      path  := <lookup-index-path> (ns, paths)
      
  // TODO take type into account
  index-resolve(|paths, target):
    Regular(ns, name, type) -> <index-lookup-name> (ns, name', path)
    where
      name' := <strip-annos> name;
      path  := <lookup-index-path> (ns, paths)
  
  index-resolve(|paths, target):
    Child(ns, name, pns, parent) -> <index-lookup-child-name> (ns, name', pns, path)
    where
      name'           := <strip-annos> name;
      Def([pns|path]) := <index-resolve(|paths, parent)> Regular(pns, parent)
      
  // TODO take type into account
  index-resolve(|paths, target):
    Child(ns, name, pns, parent, type) -> <index-lookup-child-name> (ns, name', pns, path)
    where
      name'           := <strip-annos> name;
      Def([pns|path]) := <index-resolve(|paths, parent)> Regular(pns, parent)

rules // completion rules for phase 3

  index-complete(|paths, target):
    Regular(ns, COMPLETION(name)) -> <index-lookup-prefix> (ns, name, path)
    where
      path := <lookup-index-path> (ns, paths)

  // TODO take type into account??
  index-complete(|paths, target):
    Regular(ns, COMPLETION(name), type) -> <index-lookup-prefix> (ns, name, path)
    where
      path := <lookup-index-path> (ns, paths)

  index-complete(|paths, target):
    Child(ns, COMPLETION(name), pns, parent) -> <index-lookup-child-prefix> (ns, name, path)
    where
      path := <lookup-index-path> (ns, paths)

  // TODO take type into account??
  index-resolve(|paths, target):
    Child(ns, COMPLETION(name), pns, parent, type) -> <index-lookup-child-prefix> (ns, name, path)
    where
      path := <lookup-index-path> (ns, paths)

rules // name-based lookup, first result
  
  index-lookup-element =
    index-uri => [ns, name|path] ; <index-lookup-name> (ns, name, path)
    
  
  index-lookup-child-name:
    (ns, name, path) -> <index-lookup-child(index-first-name(|name))> [ns|path]
  
  index-lookup-name:
    (ns, name, path) -> <index-lookup(index-first-name(|name))> [ns|path]
    
  index-lookup-local-name:
    (ns, name, path) -> <index-lookup-local(index-first-name(|name))> [ns|path]
  
  index-lookup-imported-name:
    (ns, name, path) -> <index-lookup-imported(index-first-name(|name))> [ns|path]

rules // name-based lookup, all results
  
  index-lookup-all-element =
    index-uri => [ns, name|path] ; <index-lookup-all-name> (ns, name, path)
  
  
  index-lookup-children-name:
    (ns, name, path) -> <index-lookup-child(index-all-name(|name))> [ns|path]
  
  index-lookup-all-name:
    (ns, name, path) -> <index-lookup(index-all-name(|name))> [ns|path]
    
  index-lookup-all-local-name:
    (ns, name, path) -> <index-lookup-local(index-all-name(|name))> [ns|path]
  
  index-lookup-all-imported-name:
    (ns, name, path) -> <index-lookup-imported(index-all-name(|name))> [ns|path]
  
rules // prefix-based lookup
  
  index-lookup-prefix-element(|prefix) =
    index-uri => [ns|path] ; <index-lookup-prefix> (ns, prefix, path)
    
  index-lookup-child-prefix-element(|ns, prefix) =
    index-uri => [_|path] ; <index-lookup-prefix> (ns, prefix, path)
    
  
  index-lookup-child-prefix:
    (ns, prefix, path) -> <index-lookup-child(index-all-prefix(|prefix))> [ns|path]
  
  index-lookup-prefix:
    (ns, prefix, path) -> <index-lookup-all(index-all-prefix(|prefix))> [ns|path]
    
  index-lookup-local-prefix:
    (ns, prefix, path) -> <index-lookup-local(index-all-prefix(|prefix))> [ns|path]
  
  index-lookup-imported-prefix:
    (ns, prefix, path) -> <index-lookup-imported(index-all-prefix(|prefix))> [ns|path]
  
rules // generic lookups
  
  index-lookup-child(select) = 
    index-unique-path ; index-lookup-local(select)
    
  // extends path with its unique extension
  index-unique-path:
    [ns|path] -> [ns|<index-get-value <+ !path> DefData([ns|path], Unique(), ())]   
      
  // path -> list of selected children
  index-lookup-local(select):
    ns-path -> definition
    where
      candidate* := <prim("LANG_index_get_children", Def(ns-path))>;
      definition := <select> candidate*
  
  // path -> list of selected imports
  index-lookup-imported(select) =
    index-import-paths; 
    select 
  
  // performs a lookup in current and enclosing scopes
  // stops on first result
  // considers imports
  index-lookup(select) =
    index-lookup-local(select) <+
    index-lookup-imported(fetch-elem(index-lookup-local(select))) <+
    ([id|Tl]; index-lookup(select))

  // performs a lookup in current and enclosing scopes
  // combines the results
  // considers imports
  index-lookup-all(select):
    p -> [local*, imported*, scoped*]
    where
      local*    := <index-lookup-local(select)> p;
      imported* := <index-lookup-imported(filter(index-lookup-local(select))); concat> p;
      scoped*   := <([id|Tl]; index-lookup-all(select)) <+ ![]> p
      
rules // helper for imports
  
  index-import-paths = MkSingleton ; index-import-paths(|[], [])
   
  /**
   * Finds all import paths.
   * 
   * i*: accumulator for the result
   * t*: already analyzed paths
   *
   * list of paths to consider -> list of all import paths
   *
   * @internal
   */
  index-import-paths(|i*, t*): 
    [] -> i*
  
  index-import-paths(|i*, t*): 
    [p|p*] -> p'*
    where
      [ns|path] := p;
      if <elem> (p, t*) then
        p'* := <index-import-paths(|i*, t*)> p*
      else
        i'* := <indexlib-get-all-values; map(index-uri; [!ns|id]; index-unique-path)> DefData(p, Import(), ());
        t'* := <indexlib-get-all-values; map(index-uri; [!ns|id]; index-unique-path)> DefData(p, TImport(), ());
        p'* := <index-import-paths(|[i*, i'*], [p, t*])> [p*, t'*]
      end

rules // low-level comparisons

  index-first-name(|name) = 
    fetch-elem(index-compare-name-equal(|name))
 
  index-all-name(|name) = 
    filter(index-compare-name-equal(|name))
 
  index-all-prefix(|prefix) =
    filter(index-compare-name-substring(|prefix))
 
   /**
   * Compares given element (with an URI) to given name using string equality comparison.
   * 
   * @internal 
   */     
  index-compare-name-equal(|name) =
    where(
      ?Def([_,<id>|_]); 
      SRTS-EXT-eq-ignore-annos(|name)
    )
       
  /**
   * Compares given element (with an URI) to given prefix using substring comparison.
   * 
   * @internal 
   */     
  index-compare-name-substring(|prefix) =
    where (
      ?Def([_,<id>|_]); 
      is-substring(!prefix)
    )
      
  /**
   * Compares given element (with an URI) to given prefix using substring comparison and given namespace.
   * 
   * @internal 
   */      
  index-compare-name-substring(|prefix, namespace) =
    where (
      ?Def([ns,name|_]); 
      <eq> (namespace, ns);
      <is-substring(!prefix)> name
   )
   
rules // interface to NBL generator for phase 3
  
  /** @internal */
  nam-get-uses 
    = fail
  
  /** @internal */
  nam-resolve(target) 
    = fail

rules // Final: storing analyzed AST
       
  /**
   * Stores AST from file to the index.
   *
   * @internal
   */   
  analyze-top-store-ast(|full-path):
    (ast, (_, subfile)) -> <id>
    where
      <index-add(|full-path)> AST(subfile, ast)

  /**
   * Stores AST from file to the index.
   *
   * @internal
   */   
  analyze-top-store-ast(|full-path):
    (ast, file) -> <id>
    where
      <is-string> file;
      <index-add(|full-path)> AST([AST()], ast)
                  
rules // Parallel analysis
  
  /** @internal */
  index-parallel-analyze(analyze):
    files -> allResults
    with
      map(index-parse-file); // Parsing cannot be done in parallel.
      map(\(ast, file) -> (ast, file, <project-path>)\);
      parallel-unordered(all(index-analyze(analyze)));
      ?results;
      with(<eq> (<length> results, <length> files) | "Input size not equal to output size");
      filesToAnalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
      if not([] := filesToAnalyze) then
        allResults := <concat> [results, <index-parallel-analyze(analyze)> filesToAnalyze]
      else
        allResults := results
      end
  
  /** @internal */   
  index-parse-file:
    file -> (ast', file)
    with
      if <file-exists> file then
        if ast := <parse-file> file then
          ast' := ast
        else
          ast' := ()
        end
      else
        ast' := ()
      end
   
  /** @internal */   
  index-set-markers:
    ParallelResults(ast, ast', errors, warnings, notes, diffs) -> <id>
    with
      <set-markers(|ast)> (ast', errors, warnings, notes)
      
  /** @internal */
  index-analyze(analyze):
    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, filesToAnalyze)
    with
      (ast', errors, warnings, notes, filesToAnalyze) := <analyze>;
      if [] := filesToAnalyze then
        complete-work-unit
      end
      
/** @internal */
rules // Splitter
  
  /** @internal */
  index-split = fail
  /** @internal */
  index-is-toplevel = fail
  /** @internal */
  index-is-qualifier = fail
  /** @internal */
  index-qualifier-subelements = fail
  /** @internal */
  index-create-qualifier(|qualifier) = fail
  
  /** @internal */
  index-toplevel-split:
    ast -> asts'
    with
      (ast', _) := <analyze-defs> ast;
      asts      := <index-toplevel-split-internal> ast';
      asts'     := <strip-annos> asts
      
  /** @internal */
  index-toplevel-split-internal:
    node -> units
    with
      switch id
        case ?():
          units := [((), [])]
        case index-is-qualifier:
          elems := <mapconcat(index-toplevel-split-internal)> <index-qualifier-subelements> node;
          units := <map(index-transform-qualifier(|node))> elems
        case index-is-toplevel:
          units := [(node, <index-uri> <nam-get-definition-keys; Hd> node)]
        otherwise:
          units := [(node, [])]
      end
      
  /** @internal */
  index-transform-qualifier(|node):
    (elem, subfileName) -> (qualifier, subfileName)
    with
      qualifier := <index-create-qualifier(|node)> elem

/** @internal */
rules // Diffs
  
  /** @internal */
  analyze-diff:
    (defs1, defs2) -> (added, removed)
    with
      added   := <diff(index-diff-compare)> (defs2, defs1);
      removed := <diff(index-diff-compare)> (defs1, defs2)
    
  /** @internal */
  analyze-store-diff(|changedEntries, revision): 
    astFilePairs -> analyzeFiles'
    with
      changedFiles    := <mapconcat(index-get-files-of)> changedEntries;
      dependentFiles  := <index-get-dependent-files> changedEntries;
      
      // Files to analyze
      analyzeFiles := <make-set> <remove-all(fake-file)> dependentFiles;
      analyzeFiles' := analyzeFiles;
      // TODO: Is this extra check needed?
      /*if <getfirst(index-get-file-revision; \r -> (r, revision)\; gt)> analyzeFiles then
        // Add current file if the current file has read information from another file with a higher revision.
        // This indicates that potentially outdated information was read.
        analyzeFiles' := [file|analyzeFiles]
      else
        analyzeFiles' := analyzeFiles
      end;*/
      
      // Files to compile
      changedAstFiles := <filter(analyze-astdiff)> astFilePairs;
      compileFiles := <make-set> <concat> [analyzeFiles', changedFiles, changedAstFiles];
      // TODO: Optimize so that there are no duplicate files stored in the index, use iset?
      <map(analyze-add-compilediff)> compileFiles
      
  /** 
   * Checks if ast for given file has changed. Succeeds if old ASTDiff is not found or if ASTDiff is different.
   *
   * @internal
   */
  analyze-astdiff:
    (ast, file) -> file
    where
      name := <conc> (<index-file-to-uri> file, ["ast-checksum"]);
      newChecksum := <checksum> ast;
      if oldChecksum := <index-get-global(|name)> then
        <index-set-global(|name)> newChecksum;
        not(<eq> (oldChecksum, newChecksum))
      else
        <index-set-global(|name)> newChecksum
      end
      
  /** 
   * Adds given file to the list of files to compile.
   *
   * @internal
   */
  analyze-add-compilediff = index-add-global(|"compile-diff")
  
  /** 
   * Gets the list of files to compile, and then clear it.
   *
   * @internal
   */
  analyze-get-compilediffs = index-get-all-globals(|"compile-diff"); index-clear-global(|"compile-diff")
             
rules // URI and value projections
       
  /** @internal */
  index-uri-impl:
    Def(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    Use(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    Read(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    x{[namespace | path]} -> [<index-namespace-unwrap> namespace | path]
 
  /**
   * TODO: Should second part of ReadWildcard be included in the URI, between namespace and path?
   * 
   * @internal 
   */
  index-uri-impl:
    ReadWildcard(uri, _) -> uri

  /** @internal */
  index-value-impl:
    Def(value) -> value

  /** @internal */
  index-value-impl:
    Use(value) -> value

  /** @internal */
  index-value-impl:
    Read(value) -> value
  
  /** @internal */
  index-value-impl:
    ReadWildcard(_, value) -> value
    
rules // Internal helpers

  /**
   * Tests if the current file is just a testing language input
   *
   * @internal
   */
  is-test-file = 
    string-ends-with(|".spt")
  /** @internal */
  is-test-language = 
    ?"Spoofax-Testing"
  /** @internal */
  is-test-input(|language, path) = 
    <is-test-language> language <+ <is-test-file> path
      
  /** @internal */
  fake-file = 
    is-test-file <+ index-is-fake-file
  
  /** @internal */
  ast-uri-to-ast-file(|full-path):
    (ast, uri) -> (ast, (full-path, uri))
   
  /** @internal */    
  index-readwildcard-substring(|prefix):
    ReadWildcard(_, name) -> <id>
    where <is-substring(!prefix)> name
  
  /** @internal */  
  store-wildcard-read(|namespace, path, prefix):
    children -> <id>
    with
      if set := <Index-ReadSet> then
        if 1 := <length> children then
          // HACK: This solves the problem of ReadWildcards making too many files re-analyze, but this should
          // be handled in the index primitives instead.
          <iset-add(|Read([namespace, prefix|path]))> set
        else
          <iset-add(|ReadWildcard([namespace|path], prefix))> set
        end
      end
  
  /** @internal */    
  index-is-unresolved(|x, uri) = 
    Index-UnresolvedSet; (iset-contains(|(x, uri)) <+ fail)
  /** @internal */
  index-add-unresolved(|x, uri) = 
    (Index-UnresolvedSet; iset-add(|(x, uri))) <+ id
  
  /** @internal */
  index-file-dependent-construct: 
    uri -> <conc> (uses, reads)
    with
      uses := <index-get-uses-all> Def(uri);
      reads := <index-get-reads-all> Def(uri)
  
  /** @internal */  
  index-file-dependency-filter = 
    ?Read(_) <+ ?ReadWildcard(_, _) <+ ?Use(_)
 
  /** @internal */
  index-eq(|namespace, expected) =
    where(
      ?Def([_, name | _]);
      <SRTS-EXT-eq-ignore-annos(|expected)> name
    )
  
  /** @internal */
  external SRTS-EXT-eq-ignore-annos(|t)
  
  /** @internal */
  index-key-unwrap = 
    \key{uri} -> key{<index-uri-unwrap> uri}\ <+ id