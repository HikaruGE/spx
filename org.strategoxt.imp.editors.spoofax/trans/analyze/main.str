module analyze/main

imports 
	context/sdf/declare
	context/-
	normalize/signatures
imports 
	include/SpoofaxLang
imports
	common
	utils/annotations
	utils/debug	
imports 
	analyze/sdf/check 
	analyze/esv/check
	analyze/str/check 
	analyze/check-module
	analyze/check-package
	analyze/check-project
imports	
	lib/editor-common.generated
imports 
	utils/cache
	utils/debug
	utils/contract
	spoofaxlang

rules 
	// performs static analysis and semantic checking 
	analyze-main = 
		?list-of-package-qnames
		;<analyze-global>()
		;<list-loop(analyze-spx-package)>list-of-package-qnames

	
rules	// Package specific semantic error checking 

	// verify whether this package will be analyzed or not
	should-analyze-this-package = 
		?package-qname;
		where(not(<AnalyzedPackage>package-qname))
	
	// Fails if there is any semantic problems 
	fail-if-has-errors : problems@(errors, warning, infos*) -> problems
		where 
			if not(!errors => []) then 
		 		fail	
		 	end		 	 	

	// Analyzes SPX packages. 
	analyze-spx-package: 
		package-typed-qname@Package(untyped-qname) -> <id>
		where 
			<debug-analysis> $[Analyze| Analyze-spx-package| Planning to Analyze : [<pp-aterm>]] 
		where
				if should-analyze-this-package  then //FOR handling circular referneces   
					{|GetEnclosingPackageName:
							rules ( GetEnclosingPackageName      := package-typed-qname);
							<analyze>package-typed-qname;
							<list-loop(
									analyze-spx-module
								)
							><get-enclosed-modules>package-typed-qname
					|};		
				package-abs-path := <DeclaredPackage>untyped-qname;
				where(
					rules(
						AnalyzedPackage: package-typed-qname -> package-typed-qname
						AnalyzedPackageDeclaredIn:+ package-abs-path -> package-typed-qname
					)
				)
				<+
				<debug-analysis> $[Analyze| analyze-spx-package > [<pp-aterm>package-typed-qname] Failed. ];
				fail
			end
			
	// Perform analysis on module definition 
	analyze-spx-module: 
		module-typed-qname@Module(untyped-qname) -> <id>
		where 
			<debug-analysis> $[Analyze|  analyze-spx-module> Planning to analyze module for semantic problems: [<pp-aterm>]] 
		where 
			if not(<AnalyzedModule>module-typed-qname) then
					<debug-analysis> $[Analyze| analyze-spx-module> Currently Analyzing : [<pp-aterm>]]; 
					module-decl* := <get-module-declarations>module-typed-qname;
					{|GetEnclosingModuleName:
							rules( GetEnclosingModuleName := module-typed-qname);
							<list-loop(
									analyze-module-definition
							 )>module-decl* 
					|};
					module-abs-path := <DeclaredModule>untyped-qname;
					where(
						rules(
							AnalyzedModule:     module-typed-qname -> module-typed-qname 
							AnalyzedModulesDeclaredIn:+ module-abs-path -> module-typed-qname
						)
					)
				<+ 
					<debug-analysis> $[Analyze| analyze-spx-module| [<pp-aterm>module-typed-qname] Failed. ]
					;fail
			else
				<debug-analysis> $[Analyze| analyze-spx-module| Ignored as already in the queue :[<pp-aterm>]] //this package is not compiled before
			end		
	

rules
	
	//lookups for the analyzed problems
	get-all-analyzed-problems =  all-keys-GetSemanticProblems ; map(GetSemanticProblems); unzip-semantic-issuses 
	
	
	get-semantic-problmes-by-file : file-abs-path ->problems
		where
			problems-at-modules*  := <get-semantic-problems(get-semantic-problmes-at-module-level)><bagof-AnalyzedModulesDeclaredIn>file-abs-path;
			problems-at-packages* := <get-semantic-problems(get-semantic-problmes-at-package-level)><bagof-AnalyzedPackageDeclaredIn>file-abs-path;
			problems := <merge-semantic-problems> ( problems-at-modules*   , problems-at-packages*) 
			
	
	get-semantic-problems(s): scopes* -> problems
	where
			<map(s)>scopes* => problmes-zipped* ;  
			<unzip-semantic-issuses>problmes-zipped* => problems
	
	get-semantic-problmes-at-package-level : p@Package(QName(_)) -> problems-package-level
		where
			<GetSemanticProblems>p => problems-package-level 
	
	get-semantic-problmes-at-module-level : module-typed-qname -> problems-module-level
	where
			<debug-compiler>$[ErrorChecking | Caching semantic issues for module [<pp-aterm>]]
	where
		<GetEnclosingScope> module-typed-qname => package-typed-qname;
		<get-analyzed-problems-of> (package-typed-qname,module-typed-qname)=>problems-module-level
		
	<+
		problems-module-level := ([] , [] , [])
	where
		<debug-compiler>$[ErrorChecking | Found Problems for this module : [<pp-aterm>problems-module-level]]	
 
 
	get-analyzed-problems-of: scope@(package-typed-qname, module-typed-qname) -> problems
		where 
			contracts (
					contract-requires(?Package(QName(_)) |package-typed-qname);
					contract-requires(?Module(QName(_))  |module-typed-qname)
			)	
			;<GetSemanticProblems>scope 							=> problems
		where
			<debug-compiler> $[ErrorChecking |  Problmes found [<pp-aterm-forced>scope] :  [<pp-aterm-forced>problems]]
				
rules 
			
	merge-semantic-problems : (unziped-issues1 , unzipped-issues2)-> semantic-problems*
	with 
		!unziped-issues1  =>(merrors,mwarnings,minfos);
		!unzipped-issues2 =>(err, warning, info);
		combined-problmes* := [(merrors,mwarnings,minfos),(err, warning, info)]
	where		
		<unzip-semantic-issuses>combined-problmes* => semantic-problems* 

	/* Converts a list as following 
					[([a1] , [b1] , [c1])
					([a2] , [b2] , [c2])
					([a3] , [b3] , [c3])
					] 
		to:
				([a1,a2,a3] , [b1,b2,b3] , [c1,c2,c3])
				
	*/
	unzip-semantic-issuses:
		list-of-semantic-issues -> unziped-list
		where
				<unzip-semantic-issuse(|[] , [], [])>list-of-semantic-issues => unziped-list
			<+
				debug(!"unzip semantic issues failed : ");fail
	
	//unziping list of semantic issues
	unzip-semantic-issuse(|errors, warnings, infos) =
		?[hd-issue|rest-issues];
		(
				(!hd-issue => (errs', warns' , infos') <+ <debug> $["Illegal Argument in unzip-semantic-issues : [<pp-aterm>hd-issue]"];fail)
				;err1 := <concat>[errs', errors]
				;war1 := <concat>[warns', warnings]
				;inf1 := <concat>[infos', infos]
				;<unzip-semantic-issuse(|err1, war1, inf1)>rest-issues
			 <+
			  !hd-issue => [];
			  <unzip-semantic-issuse(|errors, warnings, infos)>rest-issues
		)
		
	unzip-semantic-issuse(|errors, warning, infos) : [] -> (errors, warning, infos)		

	
rules			// Caching Resulting Semantic Errors 	

	cache-semantic-problems: () -> ()
	where
		all-keys-AnalyzedModulesDeclaredIn => list-file*;
	 	<map(store-semantic-problmes)> list-file*
	
	store-semantic-problmes : filepath -> filepath
	where
		<debug-compiler>$[Caching | Caching semantic issues : [<pp-aterm>]]
	where 
		<get-semantic-problmes-by-file> filepath=> problmes-to-save*
	where
		<debug-compiler>$[Caching | Saving problems: [<pp-aterm>problmes-to-save*]];
		<cache-semantic-issues>( filepath , problmes-to-save*)
