module codegen/generate

imports 
	codegen/compile
	codegen/sdf/to-sdf
	codegen/sdf/to-signature 
	codegen/str/to-stratego
	codegen/esv/to-esv
	codegen/buildscripts

imports 
	config 
	common
imports	
	lib/editor-common.generated
	include/SpoofaxLang
imports	
	context/-
	normalize/signatures
imports 	
	utils/path 
	utils/annotations
	utils/contract
	utils/debug
	utils/cache
	analyze/main
	codegen/generate
			
		
strategies 
	build-all(gen-code) = 
		?current-term
		;new-compile-session(
			list-of-package-qname* := <get-package-list> 
			;<compile-internal>list-of-package-qname*
			;<debug>$[-------------------Getting list of errors-------------------]
			;<get-all-analyzed-problems>() => problems  
			;if <fail-if-has-errors>problems then
			 	{| ImportedDef : 
							<gen-code>() 
				|} 		
			else
				<debug>$[Please fix the errors before building the artifacts:  [<pp-aterm-forced>problems]]
			end		 
		)
		;!current-term //restoring current term to avoid side effects  

	
	generate-artifacts-all : () -> ()
		where
			<debug>$[-------------------Generating artifacts-------------------]
			;init-code-generation
		  ;list-of-package-qname* := <get-package-list>   
			;<debug>$[-------------------Generating artifacts for following ALL spx -------------------]
			;<list-loop(generate-spx-package)>list-of-package-qname*
			;<debug>$[-------------------------Generating Build Scipt---------------------]
			;<emit-build-script> <filter(has-language-name-configured)>list-of-package-qname*
			;<debug>$[-------------------------Code Generation is done-------------------------] 


	generate-artifacts-incrementally : () -> ()
		where
			<debug>$[-------------------Generating artefacts-------------------]
			;init-code-generation
		  ;seperate-compilable-spx-files := <get-all-modified-compilation-units>
		  ;if !seperate-compilable-spx-files => [] then 
		  	<debug>$[-------------------------No Changes found-------------------------] 
		  else	 
			  list-of-package-qname* := <get-packages-of-file>seperate-compilable-spx-files   
				;<debug>$[-------------------Generating artifacts for following spx : [<pp-aterm>seperate-compilable-spx-files]-------------------]
				;<list-loop(generate-spx-package)>list-of-package-qname*
				;<debug>$[-------------------------Generating Build Scipt---------------------]
				;<emit-build-script> <filter(has-language-name-configured)>list-of-package-qname*
		 	end
		 	;<debug>$[-------------------------Code Generation is done-------------------------] 

		 			
	get-packages-of-file = mapconcat(get-packages-of-file) ; make-set 
				
rules 
	
	refresh-file = is-in-command-line-mode  < id + refresh-workspace-file 

//TODO: OPTIMIZE : get the imports and resue it in all the generation phase rather traversing to find it out each time. 
//TODO: OPTIMIZE : DR can be used to construct this imports  
rules 
	
	init-code-generation = where(<emit-default-signatures>()) 
	
	generate-all = emit-sdf;emit-signatures ; emit-str <+ debug(!" Failed in Generate-all. "); fail

	generate-main = 
			?module-qname* ;generate-sdf-main;generate-str-main ; generate-esv-main 
		<+ 
			debug(!" Failed in Main Generation. "); fail    

rules

	should-generate-code-this-package = 
		?package-qname;
		where(not(<PackageCodeGenerated>package-qname))
		
	// generates artifact for spx packages 
	generate-spx-package: 
		package-typed-qname@Package(untyped-qname) -> <id>
		where 
			<debug-compiler> $[Generate| Generate code for spx-package| Generating Artifacts for following package: [<pp-aterm>]] 
		with 
			enclosed-module-typed-qnames := <get-enclosed-modules>package-typed-qname
		where
			if should-generate-code-this-package  then 
				{|GetEnclosingPackageName,GeneratedSignature:
					 	rules (GetEnclosingPackageName := package-typed-qname);
						// Generates artifacts from all the modules 	
						<list-loop(generate-spx-module)>enclosed-module-typed-qnames;
						<emit-internal-signatures>package-typed-qname;
						if (language-name  := <get-language-name> package-typed-qname) then
							// Since, the language-name is defined for this language 
							// generate all the main artifacts  for this package
							// if Language name is not defined for certain packaged, they will not be considered 
							// as a language , rather will be treated as a langauge library to be reused by other 
							// languages.
							
							{| GetLanguageName : 
										<debug>$[-------------------------Generating Main Artifacts ---------------------];
										<debug>$[------------------------------------------------------------------------];
										rules( GetLanguageName  := language-name);
										<emit-package-signature-main>();
										<generate-main> enclosed-module-typed-qnames 
							|}  
						end	  
				|};		
				where(rules(PackageCodeGenerated: package-typed-qname -> package-typed-qname)) // TODO : delete this rules. probably , it is reduntant 
			<+
				<debug-compiler> $[Generate| generate-spx-package > [<pp-aterm>package-typed-qname] Failed. ]
				;fail
			end
	
	// generates artifacts fro spx module
	generate-spx-module: 
		module-typed-qname@Module(untyped-qname) -> <id>
		where 
			<debug-compiler> $[Generate|  generate-spx-module> Planning to generate module for semantic problems: [<pp-aterm>]] 
		where 
			if not(<ModuleCodeGenerated>module-typed-qname) then
				<debug-compiler> $[Generate| generate-spx-module| Currently Generating : [<pp-aterm>]]; 
				module-decl* := <get-original-module-declaration>module-typed-qname;
				{|GetEnclosingModuleName:
						rules( GetEnclosingModuleName := module-typed-qname);
						
								<generate-all> module-decl* 	// generating all the artifacts for the specified module
				|};
				module-abs-path := <DeclaredModule>untyped-qname;
				where(
					rules(
						ModuleCodeGenerated:     module-typed-qname -> module-typed-qname
					)
				)
				<+
				<debug-compiler> $[Generate| generate-spx-module| [<pp-aterm>module-typed-qname] Failed. ]
				;fail
			else
				<debug-compiler> $[Generate| generate-spx-module| Ignored as already in the queue :[<pp-aterm>]] //this package is not compiled before
			end		
			
	get-main-file-name : () ->lang-name 
	with 
		lang-name := <GetLanguageName> <+ debug(!"GetLanguageName encountered error. Please verify it is called within the scope defined for the DR")

	
		
rules
	to-generated-artifact-block(adapter, post-coversion-adapter) : list-stmt* -> resultant-block* 
	with contracts( 
		contract-requires(is-list |list-stmt*)
	)
	where 
		<adapter>list-stmt*  => adapted-result*; // results are  adapted using the specified adapter
		<post-coversion-adapter>adapted-result*  => resultant-block*

rules
	// generates the import declaration for the artifacts .  
	// s is a artifact specific adapted strategy applied to all the import declaration 
	// to get the artifact-specific import declaration. 
	to-generated-artifacts-import-declarations(s) =
		?imports*;	map(to-import-declaration(s)); flatten-list;	make-set; 	where(<debug-compiler>$[Codegen | Imports | Resultant imports :  [<pp-aterm>]]) 
		
	to-import-declaration(s): 
		i@ImportPackage(package-qname@QName(_)) -> results
		where 
			if not(<DeclaredPackage>package-qname) then
				results := [] // unresolved imports. ignore. 
			else
				<get-enclosed-modules>Package(package-qname) => modules*;
				<map(?Module(<id>) ; qname-to-path ; s)> modules* => results
			end
		where
			<debug-compiler>$[ Codegen | Imports Conversion |  import package Result : [<pp-aterm>results] ]
	
	to-import-declaration(s):		
		ImportSpxModule(Name(package-name), SPXModuleName(modname)) -> <to-import-declaration(s)>ImportSpxModule(QName([package-name]), SPXModuleName(modname))
	
	to-import-declaration(s):
		ImportSpxModule(QName(package-qname-parts), SPXModuleName(modname)) -> result
		where
			 module-qname 			 := <get-module-untyped-qname> (package-qname-parts , modname)
			;if(not(<DeclaredModule>module-qname))  then
				result := [] // unresolved imports. ignore. 
			else
				module-name-path    := <qname-to-path>module-qname
				;<s>module-name-path => result'
				;result := [result']  
			end
		where 
			<debug-compiler>$[ Codegen | Imports Conversion  | import module Result:  [<pp-aterm>result]] 
		 
	to-import-declaration(s): 
		ImportPackage(Name(package-name)) -> result
		where
			if <DeclaredPackage>QName([package-name]) then
				<get-enclosed-modules>Package(QName([package-name])) => modules*
				;<map(?Module(<id>) ; qname-to-path ; s)> modules*   => result
			else
				 // since it is not declared as a spx package , it could be a legacy artifact . 
				 result := <to-import-declaration(s)>ImportLegacyArtifact(Name(package-name))
			end
		where 
			<debug-compiler>$[ Codegen | Imports Conversion  | import pcakage/legacy artifact Result :  [<pp-aterm>result]] 
	
	to-import-declaration(s): 
		ImportLegacyArtifact(Name(modulename)) -> result
		where 
				<s>Name(modulename) => result
		where 
			<debug-compiler>$[Codegen | Imports Conversion |  import legacy artifact Result : [<pp-aterm>result].]
	
	

rules 
	save-artifact(s | package-untyped-qname, root-directory,output-path) : 
		content -> content
		with 
			 <ensure-exists>(root-directory, package-untyped-qname)
		 	;<s>(output-path , content)
		 	;<refresh-file>output-path 
		 	;chdir-to-project-path
		
	
	save-artifact( | package-untyped-qname, root-directory,output-path) : 
		content -> <save-artifact( save-to-file | package-untyped-qname, root-directory,output-path)>content 


rules
	
	// Verifies wheter a particular list is empty or not.
	ensure-list-is-not-empty =  contracts(contract-requires (is-list| <id>)); is-not-empty-list
		
	has-language-name-configured = ?Package(QName(_)) ; where(get-language-name)
	
	get-all-imported-defs = bagof-ImportedDef
		
		
	
	
				 