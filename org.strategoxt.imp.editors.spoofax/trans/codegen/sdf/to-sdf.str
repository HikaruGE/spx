module codegen/sdf/to-sdf

imports
  libstratego-lib
  libstratego-gpp
  libstratego-sglr
  libstratego-sdf
imports
	include/SpoofaxLang
	lib/editor-common.generated
  lib/sdf-desugar
  lib/sdf-parenthesize  
imports 
	context/scope-tree
	context/signature
	context/sdf/declare
imports
	normalize/signatures
imports 
	common
	config
	utils/annotations
	utils/path
	utils/debug
imports 	 
	codegen/main
	codegen/generate  
	utils/contract
	
      
rules
 
	 emit-sdf:m@Module(attrb* , modname , section*) -> m
 		with 
 			project-path := <ProjectPath>
 		where
 			package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			<debug-compiler>$[ Codegen | SDF | Failed to create current scope.] 
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			; Module(_, _ , section') := <get-module-declaration>module-typed-qname 
		where 
    	<debug-compiler>$[ Codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
    where
    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block>section* )
    	;<debug-compiler>$[ Codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
		where
			 autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
   		;<ensure-exists>(autogen-root-directory, package-untyped-qname)
			;output-path     := <get-output-path(|"sdf")>(autogen-root-directory , module-untyped-qname) 
			; <save-to-file>(output-path , sdf-string )
			;<refresh-file>output-path
			;chdir-to-project-path
			;<debug-compiler>$[ Codegen | SDF | Finishing generation of SDF for [<pp-aterm> module-untyped-qname].] 
		
	
	generate-sdf-main:  module-qname* -> <id>
		with 
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>;
 			 relative-autogen-path :=  <qname-to-path>package-qname
 		where 
 			<debug-compiler>$[ Codegen | SDF | Generating main for the following package : [<pp-aterm> package-qname].]
 		where
			sdf-string := 
	    $[module [<get-main-file-name>package-qname]
	         imports
		      	[<map(pp-sdf-import)>module-qname*]   									 
	     ]
	  where 
	  	<debug-compiler>$[ codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
		where
			 autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
			;autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;<ensure-exists>(autogen-root-directory , package-qname)
			;output-path := <get-main-output-path(|"sdf")>(autogen-root-directory , package-qname)   
			;<save-to-file>(output-path , sdf-string )
	 		;<refresh-file>output-path
			;chdir-to-project-path
			;<debug-compiler>$[ Codegen | SDF | Finishing generation of Main SDF Module of package : [<pp-aterm> package-qname].]
	
				
rules
	
	to-sdf-section-block : sections* -> sdf-section-block 
	with contracts( 
		contract-requires ( is-list |sections*)
	)
	where 
		sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
		if <ensure-list-is-not-empty>sdf-section* then
			sdf-section-block := <to-generated-artifact-block(list-to-conc-grammars; topdown(repeat(desugar-sdf-redux)), \s -> [exports(s)]\)>sdf-section*
		else
			sdf-section-block := []
		end 	

		
	to-sdf-imports-block : sections*  -> sdf-import-block
	with contracts( 
		contract-requires ( is-list |sections*)
	)
	where 
		spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
		if <ensure-list-is-not-empty>spx-import-stmt*  then
			sdf-import-block := <to-generated-artifact-block(to-generated-artifacts-import-declarations(sdf-import-adapter), \s -> ['imports(s)]\)>spx-import-stmt*
		else
			sdf-import-block := []
		end		
 
 	
 	sdf-import-adapter : name  -> 	'module(unparameterized(name))
 	where debug(!" in sdf-import-adapter: " )
 	where 
 		<is-string>name
 	
 	sdf-import-adapter : legacy-artifact@Name(name)  -> 	result
 	where debug(!" in sdf-import-adapter : legacy : " )
 	where 
 			if(<UsedLegacyArtifacts>(Globals(), name) => Unresolved()) then
 				result := [] 
 			else 
 				result :=  'module(unparameterized(name)) 
			end 
	where
		<debug(!" in sdf-import-adapter : legacy : " )> result		

rules

	override pp-sdf-string = fail // ensure compiler doesn't blow up
	
  pp-sdf-string' =
    sdf-desugar; 
    parenthesize-Sdf2; 
  	sdf-ppfix; 
    ast2box(|[<pp-table-sdf>]); 
    box2text-string(|80)			 

rules
  // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
  //desugar-sdf-redux:
  //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    Constructor(s) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  // HACK: remove scope from output
  desugar-sdf-redux:
    term(default(appl(unquoted("scope"), [s]))) ->
    term(default(appl(unquoted("scope"), [])))

  desugar-sdf-redux:
    namespacedef(_, s) -> s

  desugar-sdf-redux:
    namespaceref(n) -> sort(s')
    where
      s' := < resolve-NamespaceSort-declaration <+ !"ID"> n

  desugar-sdf-redux:
    namespaceref2(n, s) -> s
  
  list-to-conc-grammars:
    [g1, g2 | gs] -> conc-grammars(g1, <list-to-conc-grammars> [g2 | gs])
  
  list-to-conc-grammars:
    [g1] -> g1
  
  list-to-conc-grammars:
    [] -> []
	
rules 
	
	//pretty printing as sdf imports
	pp-sdf-import: Module(q@QName(qnameparts*))-> result 
		where 
				result := $[[<qname-to-path >q]
									 ]
			