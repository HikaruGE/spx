module codegen/sdf/to-sdf

imports
  libstratego-lib
  libstratego-gpp
  libstratego-sglr
  libstratego-sdf
  include/libtemplatelang
imports
	include/SpoofaxLang
	lib/editor-common.generated
imports
	context/-
	context/sdf/declare
imports
  normalize/main
	normalize/signatures
imports
	common
	config
	utils/annotations
	utils/path
	utils/debug
imports
	codegen/main
	codegen/generate
	utils/contract

rules

	 emit-sdf:
	 	m@Module(attrb* , modname , section*) -> m
 		where
 			with-spxverify(
 				project-path := <ProjectPath>
 				; package-typed-qname := <GetEnclosingPackageName>
				; module-typed-qname  := <GetEnclosingModuleName>
				, !"Failed to create current scope @emit-sdf"
			)	
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			 ; !package-typed-qname => Package(package-untyped-qname)
			 ;  Module(_, _ , section') := <get-desugared-module-ast>module-typed-qname
		where
			root-directory := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
   		; output-path   := <get-output-path(|"sdf")>(root-directory , module-untyped-qname)
    	; dbg-compiler(!$[ Codegen | SDF | Found Section + Imports for the following module [<print-as-string> module-untyped-qname]])
    where
      // sdf2conflicts here collects information for the parenthesation in the prettyprinter
    	sdf-string := <pp-sdf-to-string> 'module(
    																		<qname-to-path>module-untyped-qname, 
    																		<to-sdf-imports-block>section* , 
    																		<to-sdf-section-block/* TVO-FIXME: ;sdf2conflicts-store-sdf */>section* 
    																		)
    	; dbg-compiler(!$[ Codegen | SDF | Saving the artifacts of [<print-as-string> module-untyped-qname].])
			; <save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string 
			; dbg-compiler(!$[ Codegen | SDF | Finishing generation of SDF for [<print-as-string> module-untyped-qname].])

	
	
rules	
	
	generate-sdf-main:  module-qname* -> <id>
		where 
			Package(package-qname)   := <GetEnclosingPackageName>
			; dbg-compiler(!$[Codegen | SDF | Generating main failed for the following package : [<print-as-string> package-qname].])
		where 		
			with-spxverify(
		 			project-path             := <ProjectPath> 
 			 		; relative-autogen-path :=  <qname-to-path>package-qname
 			 		; autogen-dir :=$[[<get-autogenerated-artifacts-dir>]/[relative-autogen-path]]
			 		; root-directory := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
			 		; main-sdf-module-name :=<get-main-file-name><GetEnclosingPackageName> 
			 		; output-path := <get-main-output-path(|main-sdf-module-name, "sdf")>(root-directory, package-qname) 
			 		, ! $[ Codegen | SDF | Generating main failed for the following package : [<print-as-string> package-qname].]
			 )  
 			; with-spxverify(
	 				resultant-sorts := <get-sdf-start-symbols-to-sync ; is-not-empty-list <+ ![]>;
	 				if not(!resultant-sorts => []) then
		 				start-symbol-syntax := [exports(context-free-start-symbols(resultant-sorts))]
	 				else
	 					start-symbol-syntax := []
	 				end
	 				, !"getting & syncing start symbols failed"
			)
 		where
 			sdf-string :=
				<pp-sdf-to-string>
				'module(
  				unparameterized(main-sdf-module-name)
					, [imports(<map(pp-sdf-import;!'module(unparameterized(<id>)))>module-qname*)]
					, start-symbol-syntax
					)
	  	; with-spxverify(
					<save-artifact(| package-qname , root-directory, output-path)>sdf-string
					, ! $[Save failed for Main SDF Module of package : [<print-as-string> package-qname]]
				)	
			
rules

	to-sdf-section-block : 
		sections* -> sdf-section-block
		where with-spxverify(
			verify( List |sections* , "List expected")
		)
		where
			sdf-section* := <conc> (
			  <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)> sections*,
			  <collect-om(?TemplateSection(_)); template-sections-to-sdf> sections*
			);
			if <ensure-list-is-not-empty>sdf-section* then
				sdf-section-block := <to-generated-artifact-block(list-to-conc-grammars; topdown(repeat(desugar-sdf-redux)), \s -> [exports(s)]\)>sdf-section*
			else
				sdf-section-block := []
			end

	to-sdf-imports-block : 
		sections*  -> sdf-import-block
		where with-spxverify(
			verify( List |sections* , "List expected")
		)
		where
			spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
			if <ensure-list-is-not-empty>spx-import-stmt*  then
				sdf-import-block := <to-generated-artifact-block(to-generated-artifacts-import-declarations(sdf-import-adapter), \s -> ['imports(s)]\)>spx-import-stmt*
			else
				sdf-import-block := []
			end

 	// Resolved Imports are alraedy filtered out in the previous step.
 	// Hence, native spx imports are added without any further
 	// verifications.
 	sdf-import-adapter : 
 		name  -> 	'module(unparameterized(name))
 		where
 			<is-string>name

	// Additional verification is done during importing legacy artifacts.
	// Here, both Unresolved libraries and Stratego Libs are Ignored.
	// Basically anything Unresolved is not added as a import statment in
	// generated SDF definition.
 	sdf-import-adapter : 
 		legacy-artifact@Name(name)  -> 	result
	 	where
	 		if <has-extension(|"sdf")+has-extension(|"def")><get-enclosed-legacy-artifact-details> then
					// Importing Legacy artifact only if it is a SDF or DEF file
					// Assumption : resolved global imports refers to stratego lib and declared in global scope.
					result :=  'module(unparameterized(name)) ;
					<record-def-import-reference>name
			else
					result :=  []
			end

	// Recoding references of def file so that we can specify -Idef arguments in pack-sdf
	// It would have been much cleaner if Pack-SDF by defult supports it without specifying this extra arguments.
	record-def-import-reference =
		where(
			?qualified-def-name;
			// Verifying whether it is indeed a def file.
			if (<has-extension(|"def")> <get-enclosed-legacy-artifact-details>) then
				package-typed-qname := <GetEnclosingPackageName> ;
				<index-imported-def-of-package>(package-typed-qname  ,qualified-def-name) 
			end
		)

overlays
  // Overlays cannot be imported from a library but still the library overlay
  // names cannot be reused here.
  sdf-cons'(x) = term(default(appl(unquoted("cons"), [fun(quoted(x))])))

rules
  // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
  //desugar-sdf-redux:
  //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    Constructor(s) -> sdf-cons'(s)

  // HACK: remove scope from output
  desugar-sdf-redux:
    term(default(appl(unquoted("scope"), [s]))) ->  term(default(appl(unquoted("scope"), [])))

  desugar-sdf-redux:
    namespacedef(_, s) -> s

  desugar-sdf-redux:
    namespaceref(n) -> sort(s')
    where
      s' := < resolve-NamespaceSort-declaration <+ !"ID"> n

  desugar-sdf-redux:
    namespaceref2(n, s) -> s

rules

	//pretty printing as sdf imports
	pp-sdf-import: 
		Module(q@QName(qnameparts*))-> result
		where
				result := $[[<qname-to-path >q]
									 ]
rules

  // TVO-FIXME: move to TemplateLang

  // (from TemplateLang)

  // Allows one to write `Sort.Cons' where a production is expected.
  // (i.e. in priority sections)

  desugar-sdf-redux:
    simple-ref-group(ref) -> simple-group(<SortCons-to-prod> ref)

  desugar-sdf-redux:
    prods-ref-group(ref*) -> prods-group(<map(SortCons-to-prod)> ref*)

  desugar-sdf-redux:
    assoc-ref-group(a, ref*) -> assoc-group(a, <map(SortCons-to-prod)> ref*)

  SortCons-to-prod:
    SortCons(sort, cons) -> t
    where 
    	with-spxverify(
				<(  resolve-atleast-one-sdf-declaration <+  
  		 	 	  debug(!"Undeclared SortCons"); 
    		 	  debug(!"all-keys-Declaration is not available at this moment: "); 
    		 	  fail
    		 	)
				  ; try(template-production-to-sdf-no-attrs)
		   >(sort, cons) => t 
			)
  
  // Hook desugar-sdf-redux to templatelang-desugar-sdf
  desugar-sdf-redux = templatelang-desugar-sdf
