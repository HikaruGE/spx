module codegen/sdf/to-sdf

imports
  libstratego-lib
  libstratego-gpp
  libstratego-sglr
  libstratego-sdf
imports
	include/SpoofaxLang
	lib/editor-common.generated
  lib/sdf-desugar
  lib/sdf-parenthesize  
imports 
	context/scope-tree
	context/signature
	context/sdf/declare
imports
	normalize/signatures
imports 
	common
	config
	utils/annotations
	utils/path
	utils/debug
imports 	 
	codegen/main
	
      
rules
 
	emit-sdf:m@Module(attrb* , modname , section*) -> m
 		with 
 			project-path := <ProjectPath>
 		where
 			package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			<debug-compiler>$[ codegen | SDF | Failed to create current scope.] 
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
		where
			Module(_, _ , section') := <get-module-declaration>module-typed-qname
			;import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> section'
		  ;sections    := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)> section*
    where 
    	<debug-compiler>$[ codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
    where
    	sections'        := <topdown(repeat(desugar-sdf-redux))> <list-to-conc-grammars> sections
     ;import-temp      := <sdf-import-declarations> import-stmt* 
     ;sdf-import-stmt* := 'imports( import-temp  )
     ;sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, [sdf-import-stmt*], [exports(sections')])
   where //set up folders
   		 autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
   		;<debug(!"autogen-root : ")>autogen-root-directory  
			;<ensure-exists>(autogen-root-directory, package-untyped-qname)
			;output-path     := <get-output-path(|"sdf")>(autogen-root-directory , module-untyped-qname)
		where 
			<debug-compiler>$[ codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
		where 
			 <save-to-file>(output-path , sdf-string )
			;<refresh-workspace-file>output-path
			;chdir-to-project-path
			
		
	generate-sdf-main:  module-qname* -> <id>
		with 
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>;
 			 relative-autogen-path :=  <qname-to-path>package-qname
 		where 
 			<debug-compiler>$[ codegen | SDF | Generating main for the following package : [<pp-aterm> package-qname].]
 		where
			sdf-string := 
	    $[module [relative-autogen-path]/[<get-main-file-name>package-qname]
	         imports
		      	[<map(pp-sdf-import)>module-qname*]   									 
	     ]
	  where 
	  	<debug-compiler>$[ codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
		where
			autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
			;autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;<ensure-exists>(autogen-root-directory , package-qname)
			;output-path := <get-main-output-path(|"sdf")>(autogen-root-directory , package-qname)   
			;<save-to-file>(output-path , sdf-string )
	 		;<refresh-workspace-file>output-path
			;chdir-to-project-path
		
		
 to-sdf-all: (def, path , project-path)  -> None()
 		
 to-sdf(|project-path): (package-name,concept-name,def) -> None()
				

rules

	override pp-sdf-string = fail // ensure compiler doesn't blow up
	
  pp-sdf-string' =
    sdf-desugar; 
    parenthesize-Sdf2; 
  	sdf-ppfix; 
    ast2box(|[<pp-table-sdf>]); 
    box2text-string(|80)			 

rules
  // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
  //desugar-sdf-redux:
  //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    Constructor(s) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    namespacedef(_, s) -> s

  desugar-sdf-redux:
    namespaceref(n) -> sort(s')
    where
      s' := < resolve-NamespaceSort-declaration <+ !"ID"> n

  desugar-sdf-redux:
    namespaceref2(n, s) -> s
  
  list-to-conc-grammars:
    [g1, g2 | gs] -> conc-grammars(g1, <list-to-conc-grammars> [g2 | gs])
  
  list-to-conc-grammars:
    [g1] -> g1
  
  list-to-conc-grammars:
    [] -> []
	
rules 
	
	// coverts name to SDF  module name
	to-sdf-import: name -> 'module(unparameterized(name))
	
	//pretty printing as sdf imports
	pp-sdf-import: Module(q@QName(qnameparts*))-> result 
		where 
				result := $[[<qname-to-path >q]
									 ]
rules
	sdf-import-declarations =
		?imports*;
		map(debug;sdf-import-declaration;debug);
		flatten-list;
		make-set;
		where(<debug-compiler>$[codegen | SDF | Resultant imports :  [<pp-aterm>]]) 
		
	sdf-import-declaration: 
		i@ImportPackage(package-qname) -> results
		where 
			<debug-compiler>$[ codegen | SDF |  SDF MAIN Result import package]
		where 
			if not(<DeclaredPackage>package-qname) then
				<debug-compiler>$[ SDF MAIN Result import package Found NA];
				results := [] // unresolved imports. ignore. 
			else
				<get-enclosed-modules>Package(package-qname) => modules*;
				<map(?Module(<id>) ; qname-to-path ; to-sdf-import)> modules* => results;
				<debug-compiler>$[ codegen | SDF |  SDF MAIN Result import package Result : ]
			end
	
	sdf-import-declaration: 
		i@ImportSpxModule(QName(package-qname-parts), SPXModuleName(modname)) -> result
		where
			 module-qname 			 := <get-module-untyped-qname> (package-qname-parts , modname)
			;if(not(<DeclaredModule>module-qname))  then
				result := [] // unresolved imports. ignore. 
			else
				module-name-path    := <qname-to-path>module-qname
				;<to-sdf-import>module-name-path => result'
				;result := [result']  
			end
		where 
			<debug-compiler>$[ codegen | SDF | import module :  [<pp-aterm>result]] 
		 
	
	sdf-import-declaration: i@ImportPackage(Name(package-name)) -> result
	where
		if <DeclaredPackage>QName([package-name]) then
			<get-enclosed-modules>Package(QName([package-name])) => modules*
			;<map(?Module(<id>) ; qname-to-path ; to-sdf-import)> modules* => result
		else
			<to-sdf-import>package-name => result'
			;result := [result']	
		end
	where 
			<debug-compiler>$[ codegen | SDF | import pcakage :  [<pp-aterm>result]] 
			
	sdf-import-declaration: 
		i@ImportLegacyArtifact(Name(modulename)) -> result
		where 
				<to-sdf-import>modulename => result'
				;result := [result']	
		where 
			<debug-compiler>$[codegen | SDF |  import legacy artifact [<pp-aterm>result].]
			