module codegen/sdf/to-sdf

imports
  libstratego-lib
  libstratego-gpp
  libstratego-sglr
  libstratego-sdf
imports
	include/SpoofaxLang
	lib/editor-common.generated
  lib/sdf-desugar
  lib/sdf-parenthesize
imports
	context/-
	context/sdf/declare
imports
  normalize/main
	normalize/signatures
imports
	common
	config
	utils/annotations
	utils/attributes
	utils/path
	utils/debug
imports
	codegen/main
	codegen/generate
	codegen/template/to-sdf
	utils/contract
	utils/sdf2conflicts

rules

	 emit-sdf:m@Module(attrb* , modname , section*) -> m
 		with
 			project-path := <ProjectPath>
 			;package-typed-qname := <GetEnclosingPackageName>
			;module-typed-qname  := <GetEnclosingModuleName>
			<+
			<debug-compiler>$[ Codegen | SDF | Failed to create current scope.];fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			; Module(_, _ , section') := <get-module-declaration>module-typed-qname
		where
			root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
   		;output-path     := <get-output-path(|"sdf")>(root-directory , module-untyped-qname)
    	;<debug-compiler>$[ Codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
    where
      // sdf2conflicts here collects information for the parenthesation in the prettyprinter
    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block;sdf2conflicts>section* )
    	;<debug-compiler>$[ Codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
		where
			<save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string;
			<debug-compiler>$[ Codegen | SDF | Finishing generation of SDF for [<pp-aterm> module-untyped-qname].]

	generate-sdf-main:  module-qname* -> <id>
		with
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>;
 			 relative-autogen-path :=  <qname-to-path>package-qname;
 			 autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]];
			 root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]];
			 main-sdf-module-name :=<get-main-file-name>();
			 output-path := <get-main-output-path(|main-sdf-module-name, "sdf")>(root-directory, package-qname);
			<debug-compiler>$[ Codegen | SDF | Generating main for the following package : [<pp-aterm> package-qname].]
 		where
			sdf-string :=
	    $[module [main-sdf-module-name]
	         imports
		      	[<map(pp-sdf-import)>module-qname*]
	     ]
	  where
	  	<debug-compiler>$[ codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
		where
			<save-artifact(| package-qname , root-directory, output-path)>sdf-string;
			<debug-compiler>$[ Codegen | SDF | Finishing generation of Main SDF Module of package : [<pp-aterm> package-qname].]

rules

	to-sdf-section-block : sections* -> sdf-section-block
	with contracts(
		contract-requires ( is-list |sections*)
	)
	where
		sdf-section* := <conc> (
		  <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)> sections*,
		  <collect-om(?TemplateSection(_)); template-sections-to-sdf> sections*
		);
		if <ensure-list-is-not-empty>sdf-section* then
			sdf-section-block := <to-generated-artifact-block(list-to-conc-grammars; topdown(repeat(desugar-sdf-redux)), \s -> [exports(s)]\)>sdf-section*
		else
			sdf-section-block := []
		end


	to-sdf-imports-block : sections*  -> sdf-import-block
	with contracts(
		contract-requires ( is-list |sections*)
	)
	where
		spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
		if <ensure-list-is-not-empty>spx-import-stmt*  then
			sdf-import-block := <to-generated-artifact-block(to-generated-artifacts-import-declarations(sdf-import-adapter), \s -> ['imports(s)]\)>spx-import-stmt*
		else
			sdf-import-block := []
		end

 	// Resolved Imports are alraedy filtered out in the previous step.
 	// Hence, native spx imports are added without any further
 	// verifications.
 	sdf-import-adapter : name  -> 	'module(unparameterized(name))
 	where
 		<is-string>name

	// Additional verification is done during importing legacy artifacts.
	// Here, both Unresolved libraries and Stratego Libs are Ignored.
	// Basically anything Unresolved is not added as a import statment in
	// generated SDF definition.
 	sdf-import-adapter : legacy-artifact@Name(name)  -> 	result
 	where debug
 	where
 		if <has-extension(|"sdf")+has-extension(|"def")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , name)then
				// Importing Legacy artifact only if it is a SDF or DEF file
				// Assumption : resolved global imports refers to stratego lib and declared in global scope.
				result :=  'module(unparameterized(name)) ;
				<record-def-import-reference>name
		else
				result :=  []
		end

	// Recoding references of def file so that we can specify -Idef arguments in pack-sdf
	// It would have been much cleaner if Pack-SDF by defult supports it without specifying this extra arguments.
	record-def-import-reference =
		where(
			?def-import-path;
			// Verifying whether it is indeed a def file.
			if (<has-extension(|"def")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , def-import-path)) then
				package-typed-qname := <GetEnclosingPackageName> ;
				rules(ImportedDef :+ package-typed-qname  ->  def-import-path)
			end
		)

rules

	override pp-sdf-string = fail // ensure compiler doesn't blow up

  pp-sdf-string' =
    sdf-desugar;
    parenthesize-Sdf2;
  	sdf-ppfix;
    ast2box(|[<pp-table-sdf>]);
    box2text-string(|80)

rules
  // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
  //desugar-sdf-redux:
  //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    Constructor(s) -> sdf-cons(s)

  // HACK: remove scope from output
  desugar-sdf-redux:
    term(default(appl(unquoted("scope"), [s]))) ->
    term(default(appl(unquoted("scope"), [])))

  desugar-sdf-redux:
    namespacedef(_, s) -> s

  desugar-sdf-redux:
    namespaceref(n) -> sort(s')
    where
      s' := < resolve-NamespaceSort-declaration <+ !"ID"> n

  desugar-sdf-redux:
    namespaceref2(n, s) -> s

rules

  list-to-conc-grammars:
    [g1, g2 | gs] -> conc-grammars(g1, <list-to-conc-grammars> [g2 | gs])

  list-to-conc-grammars:
    [g1] -> g1

  list-to-conc-grammars:
    [] -> []

rules

	//pretty printing as sdf imports
	pp-sdf-import: Module(q@QName(qnameparts*))-> result
		where
				result := $[[<qname-to-path >q]
									 ]
rules

  // (from TemplateLang)

  // Allows one to write `Sort.Cons' where a production is expected.
  // (i.e. in priority sections)

  desugar-sdf-redux:
    simple-ref-group(ref) -> simple-group(<SortCons-to-prod> ref)

  desugar-sdf-redux:
    prods-ref-group(ref*) -> prods-group(<map(SortCons-to-prod)> ref*)

  desugar-sdf-redux:
    assoc-ref-group(a, ref*) -> assoc-group(a, <map(SortCons-to-prod)> ref*)

  // FIXME: Declaration contains scoped names ((Package(QName(...)), Module(QName(...))), consOrSort)
  SortCons-to-prod:
    SortCons(sort, cons) -> t
    with t := <( Declaration <+ debug(!"Undeclared SortCons"); <debug(!"all-keys-Declaration: ")> <all-keys-Declaration>; fail )
               ; try(template-production-to-sdf-no-attrs)> (<to-scoped-symbol>sort, <to-scoped-symbol>cons)
