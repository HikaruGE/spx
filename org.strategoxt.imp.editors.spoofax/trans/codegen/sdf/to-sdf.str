module codegen/sdf/to-sdf

imports
  libstratego-lib
  libstratego-gpp
  libstratego-sglr
  libstratego-sdf
imports
	include/SpoofaxLang
	lib/editor-common.generated
  lib/sdf-desugar
  lib/sdf-parenthesize  
imports 
	context/scope-tree
	context/signature
	context/sdf/declare
imports
	normalize/signatures
imports 
	common
	config
	utils/annotations
	utils/path
	utils/debug
imports 	 
	codegen/main
	codegen/generate-all 
	utils/contract
	
      
rules
 
	 emit-sdf:m@Module(attrb* , modname , section*) -> m
 		with 
 			project-path := <ProjectPath>
 		where
 			package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			<debug-compiler>$[ Codegen | SDF | Failed to create current scope.] 
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			; Module(_, _ , section') := <get-module-declaration>module-typed-qname 
		where 
    	<debug-compiler>$[ Codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
    where
    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block>section* )
    	;<debug-compiler>$[ Codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
		where
			 autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
   		;<ensure-exists>(autogen-root-directory, package-untyped-qname)
			;output-path     := <get-output-path(|"sdf")>(autogen-root-directory , module-untyped-qname) 
			; <save-to-file>(output-path , sdf-string )
			;<refresh-workspace-file>output-path
			;chdir-to-project-path
		
	
	generate-sdf-main:  module-qname* -> <id>
		with 
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>;
 			 relative-autogen-path :=  <qname-to-path>package-qname
 		where 
 			<debug-compiler>$[ Codegen | SDF | Generating main for the following package : [<pp-aterm> package-qname].]
 		where
			sdf-string := 
	    $[module [relative-autogen-path]/[<get-main-file-name>package-qname]
	         imports
		      	[<map(pp-sdf-import)>module-qname*]   									 
	     ]
	  where 
	  	<debug-compiler>$[ codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
		where
			 autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
			;autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;<ensure-exists>(autogen-root-directory , package-qname)
			;output-path := <get-main-output-path(|"sdf")>(autogen-root-directory , package-qname)   
			;<save-to-file>(output-path , sdf-string )
	 		;<refresh-workspace-file>output-path
			;chdir-to-project-path
	
				
rules
	
	to-sdf-section-block : sections* -> sdf-section-block 
	with contracts( 
		contract-requires ( is-list |sections*)
	)
	where 
		sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
		if <ensure-list-is-not-empty>sdf-section* then
			sdf-section-block := <to-generated-artifact-block(list-to-conc-grammars; topdown(repeat(desugar-sdf-redux)), \s -> [exports(s)]\)>sdf-section*
		else
			sdf-section-block := []
		end 	

		
	to-sdf-imports-block : sections*  -> sdf-import-block
	with contracts( 
		contract-requires ( is-list |sections*)
	)
	where 
		spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
		if <ensure-list-is-not-empty>spx-import-stmt*  then
			sdf-import-block := <to-generated-artifact-block(sdf-import-declarations, \s -> ['imports(s)]\)>spx-import-stmt*
		else
			sdf-import-block := []
		end		
			

				
 
rules

	override pp-sdf-string = fail // ensure compiler doesn't blow up
	
  pp-sdf-string' =
    sdf-desugar; 
    parenthesize-Sdf2; 
  	sdf-ppfix; 
    ast2box(|[<pp-table-sdf>]); 
    box2text-string(|80)			 

rules
  // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
  //desugar-sdf-redux:
  //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    Constructor(s) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))

  desugar-sdf-redux:
    namespacedef(_, s) -> s

  desugar-sdf-redux:
    namespaceref(n) -> sort(s')
    where
      s' := < resolve-NamespaceSort-declaration <+ !"ID"> n

  desugar-sdf-redux:
    namespaceref2(n, s) -> s
  
  list-to-conc-grammars:
    [g1, g2 | gs] -> conc-grammars(g1, <list-to-conc-grammars> [g2 | gs])
  
  list-to-conc-grammars:
    [g1] -> g1
  
  list-to-conc-grammars:
    [] -> []
	
rules 
	
	// coverts name to SDF  module name
	to-sdf-import: name -> 'module(unparameterized(name))
	
	//pretty printing as sdf imports
	pp-sdf-import: Module(q@QName(qnameparts*))-> result 
		where 
				result := $[[<qname-to-path >q]
									 ]
rules
	
	sdf-import-declarations =
		?imports*;
		map(sdf-import-declaration);
		flatten-list;
		make-set;
		where(<debug-compiler>$[Codegen | SDF | Resultant imports :  [<pp-aterm>]]) 
		
		
	sdf-import-declaration: 
		i@ImportPackage(package-qname@QName(_)) -> results
		where 
			if not(<DeclaredPackage>package-qname) then
				results := [] // unresolved imports. ignore. 
			else
				<get-enclosed-modules>Package(package-qname) => modules*;
				<map(?Module(<id>) ; qname-to-path ; to-sdf-import)> modules* => results
			end
		where
			<debug-compiler>$[ Codegen | SDF |  Result import package Result : [<pp-aterm>results] ]
	
	sdf-import-declaration:		
		ImportSpxModule(Name(package-name), SPXModuleName(modname)) -> <sdf-import-declaration>ImportSpxModule(QName([package-name]), SPXModuleName(modname))
	
	sdf-import-declaration: 
		i@ImportSpxModule(QName(package-qname-parts), SPXModuleName(modname)) -> result
		where
			 module-qname 			 := <get-module-untyped-qname> (package-qname-parts , modname)
			;if(not(<DeclaredModule>module-qname))  then
				result := [] // unresolved imports. ignore. 
			else
				module-name-path    := <qname-to-path>module-qname
				;<to-sdf-import>module-name-path => result'
				;result := [result']  
			end
		where 
			<debug-compiler>$[ Codegen | SDF | import module :  [<pp-aterm>result]] 
		 
	
	sdf-import-declaration: i@ImportPackage(Name(package-name)) -> result
	where
		if <DeclaredPackage>QName([package-name]) then
			<get-enclosed-modules>Package(QName([package-name])) => modules*
			;<map(?Module(<id>) ; qname-to-path ; to-sdf-import)> modules* => result
		else
			 <to-sdf-import>package-name => result'
			;result := [result']	
		end
	where 
			<debug-compiler>$[ Codegen | SDF | import pcakage :  [<pp-aterm>result]] 
	
			
	sdf-import-declaration: 
		i@ImportLegacyArtifact(Name(modulename)) -> result
		where 
				<to-sdf-import>modulename => result'
				;result := [result']	
		where 
			<debug-compiler>$[Codegen | SDF |  import legacy artifact [<pp-aterm>result].]
			