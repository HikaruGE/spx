module codegen/sdf/to-signature
imports 
	libstratego-sglr
imports
	lib/editor-common.generated
imports 
	config
	common
imports 
	context/sdf/declare-signature
	context/sdf/declare
	codegen/sdf/to-sdf
	include/spoofaxlang
imports
	codegen/compile
	utils/path
	codegen/main
	context/signature
	normalize/signatures
	
rules
	
	/* Generating Signatures for all the SDF files */
	parse-str-string =
    parse-string(
      strsglr-report-parse-error
    | <import-term(lib/Stratego-Sugar.tbl)>
    )  
	
	to-signature-as-rtree =   
		parse-str-string ; pp-aterm
	
	emit-signatures:
		m@Module(attrb* , modname , section*) -> m
		with 
 			project-path := <ProjectPath>
 		with
 			package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			debug(!"CodeGeneration | Failed to create current scope.")
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			;!modname => SPXModuleName(modulename-string)
		where 
			debug(!"2 :")
			;sig-file-name := <get-signature-file-name>modulename-string
		where 
			<debug> $[Spoofax-lang|Generating signature for the following package : [<pp-aterm>module-typed-qname]]			
			;generated-signatures-string :=  <get-signature-contents(|sig-file-name)><get-all-signatures-as-string>
			;<debug> $[Spoofax-lang|generated signatures : [generated-signatures-string ]] 
			;signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
			
		where  
			autogen-dir := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;output-path-str 		:= <get-output-path(|"signature", "str")>(autogen-dir, module-untyped-qname)
			;output-path-rtree 		:= <get-output-path(|"signature", "rtree")>(autogen-dir, module-untyped-qname)
		where
			<debug> $[Spoofax-lang|otuput path for signatures : [output-path-str]]		
			;<ensure-exists>( autogen-dir , package-untyped-qname ) 
			;<save-to-file>( output-path-str, generated-signatures-string)
			;<save-to-file>( output-path-rtree, signatures-as-aterm-string)
			;<refresh-workspace-file>output-path-str
			;<refresh-workspace-file>output-path-rtree
			;chdir-to-project-path
			
	to-signature-all:
		(def, path , project-path) -> None()
		where  
			 	(name, relative-autogen-path) := <find-spoofax-module-name-string>(path, def)
			 	;<debug> $[Spoofax-lang|Generating signature for the following package : [name]]
			 	;sig-file-name := $[[name].signature] 
			 	;autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]] 
			 	;output-path-str 		:= <get-fullyqualified-autogen-path(|"str")>(project-path,autogen-dir , sig-file-name)
			 	;output-path-rtree 	:= <get-fullyqualified-autogen-path(|"rtree")>(project-path,autogen-dir, sig-file-name)
			 	;generated-signatures-string :=  <get-signature-contents(|sig-file-name)><get-all-signatures-as-string>
			 	;<debug> $[Spoofax-lang|generated signatures : [generated-signatures-string ]] 
			 	;signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
			 	;<debug> $[Spoofax-lang|otuput path for signatures : [output-path-str]]
			 	;<ensure-exists>( project-path , autogen-dir ) 
			 	;<save-to-file>( output-path-str, generated-signatures-string)
				;<save-to-file>( output-path-rtree, signatures-as-aterm-string)
				;rules (signature-import-path:= <append-if-not-empty(|relative-autogen-path, "/")> sig-file-name)
						  
rules 
	
	//generate signature 
	get-signature-contents(|moduleName): signatures-string ->
$[module [moduleName]
signature
    constructors
       [signatures-string]
				
signature
    constructors
          Some : a -> Option(a) 
          None : Option(a)

signature
    constructors
          Cons : a * List(a) -> List(a)
          Nil  : List(a)
          Conc : List(a) * List(a) -> List(a)
]  
 
    	
	get-all-signatures-as-string= 
			<mapconcat(bagof-Get-Operation-Declaration);operation-decl-to-string>
			<filter(?(<GetEnclosingPackageName>, <GetEnclosingModuleName>, _))>
			<all-keys-Get-Operation-Singature>
  
  operation-decl-to-string : 
		[] -> $[]
  operation-decl-to-string : 
  	[first-op-decl | rest-op-decl* ] 
  		-> $[[current-op-decl-string] 
  			[rest-op-decl-string]]
  		where 
  			(opname, operands*, resultant-sort) := first-op-decl
  			;if (!operands* => []) then
  			 	current-op-decl-string := $[[<opname-to-string>opname]: [resultant-sort]]
  			else
  				current-op-decl-string := $[[<opname-to-string>opname]: [<lhs-operands-to-string>operands*] -> [resultant-sort]]
  			end		 
  			;rest-op-decl-string := <operation-decl-to-string> rest-op-decl* 
 	
 	opname-to-string : 
 		opname -> opname-string
 		where 
 				if (!opname => "") then 
 						opname-string := $[]
				else
					 opname-string  := opname
				end
				
  lhs-operands-to-string : 
		[] -> $[]
  lhs-operands-to-string : 
  	[last] -> $[[last]] 
  lhs-operands-to-string : 
  		[hd-operand|rest*] -> $[[hd-operand-string] * [rest-operand-string]]
  		where
  				not (![] => rest*) 
  		where 
  			  hd-operand-string := hd-operand 
  			  ;rest-operand-string := <lhs-operands-to-string>rest* 