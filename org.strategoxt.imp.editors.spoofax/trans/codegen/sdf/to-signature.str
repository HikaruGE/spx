module 
	codegen/sdf/to-signature
imports 
	libstratego-sglr
imports
	lib/editor-common.generated
imports 
	config
	common
imports 
	context/sdf/declare-signature
	context/sdf/declare
	codegen/sdf/to-sdf
	include/spoofaxlang
imports
	codegen/compile
	codegen/main
	codegen/generate
	
	context/signatures
	normalize/signatures
imports 
	utils/path
	utils/debug	
	
rules
	
		parse-str-string =
    parse-string(
      strsglr-report-parse-error
    | <import-term(lib/Stratego-Sugar.tbl)>
    )  
	
	to-signature-as-rtree =   
		parse-str-string
	
	
			
rules
	
	// Temporarily needed  for the lwc project
	// TODO : consider whether we need this rules for spx framework 
	emit-package-signature-main : () -> ()
	with 
 			project-path := <ProjectPath>
 			;Package(package-qname)   := <GetEnclosingPackageName>
 			;package-name-string			:= <qname-to-string>package-qname
 	where 
			<debug-compiler>$[Codegen|Generating main signature for the packagees]
			;generated-signatures-string := $[module [package-name-string]-signatures 
			 	imports 
					[<map(\s -> $[[s]
				]\)	><all-keys-GeneratedSignature>]	
			]
			;signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
	where
		 autogen-dir := $[[project-path]/include]
	 	;output-path-str 		:=   $[[autogen-dir]/[package-name-string]-signatures.str]
	 	;output-path-rtree 		:= $[[autogen-dir]/[package-name-string]-signatures.rtree]
	 	;<ensure-path-exists>(project-path, "include") 
   	;chdir-to-project-path 
	where
		 <save-to-file>( output-path-str, generated-signatures-string)
		;<WriteToBinaryFile>(output-path-rtree, signatures-as-aterm-string)
		;<refresh-file>output-path-str
		;<refresh-file>output-path-rtree
	
	
	// Emits default signatures in Global\ directory 
	emit-default-signatures:
		() -> ()
		with 
 			project-path := <ProjectPath>;
 			sig-file-name := "Globals/Signatures";
 			sig-file-rel-path := $[[<Autogenerated-Artifacts-Dir>]/[sig-file-name]]
		where 
			<debug-compiler>$[Codegen | SDF | Generating deafult signatures]			
			;generated-signatures-string :=  <get-signature-contents(|sig-file-name,"")><get-all-signatures-as-string(?(Globals(), _))>
			;signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
		where  
			 autogen-dir := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;output-path-str 		:=   $[[autogen-dir]/[sig-file-name].str]
			;output-path-rtree 		:= $[[autogen-dir]/[sig-file-name].rtree]
			;<ensure-path-exists>(project-path, $[[<Autogenerated-Artifacts-Dir>]/Globals]) 
			;chdir-to-project-path  
		where
			<save-to-file>( output-path-str, generated-signatures-string)
			;<WriteToBinaryFile>(output-path-rtree, signatures-as-aterm-string)
			;<refresh-file>output-path-str
			;<refresh-file>output-path-rtree
		where
			rules( GeneratedSignature : sig-file-rel-path );    
			<debug-compiler>$[ Codegen | SDF | Finishing generation of default signature]
	
	// Emits signatures for the specified module definition		
	emit-signatures:
		m@Module(attrb* , modname , section*) -> m
		with 
 			project-path  := <ProjectPath>;
 			root-directory:= $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
 		with
 			 package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			<debug-compiler>$[Codegen | SDF | Failed to create current scope.]
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			;!modname => SPXModuleName(modulename-string)
		where 
			sig-file-name     :=  <get-signature-file-name><qname-to-path>module-untyped-qname;
			sig-file-rel-path := $[[<Autogenerated-Artifacts-Dir>]/[<qname-to-path>module-untyped-qname]]
		where 
			<debug-compiler>$[Codegen| SDF | Generating signature for the following module: [<pp-aterm>module-typed-qname]]			
			;imports-string := $[imports 
				Globals/Signatures
			]
			;generated-signatures-string :=  <get-signature-contents(|sig-file-name,imports-string)> <get-all-signatures-as-string(?(package-typed-qname, module-typed-qname, _))>
			;signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
		where  
			<save-artifact(save-to-file| package-untyped-qname, root-directory, <get-output-path(|"signature", "str")>(root-directory, module-untyped-qname))>generated-signatures-string;
			<save-artifact(WriteToBinaryFile| package-untyped-qname, root-directory, <get-output-path(|"signature", "rtree")>(root-directory, module-untyped-qname))>signatures-as-aterm-string;
			rules( GeneratedSignature : sig-file-rel-path )
		where
			<debug-compiler>$[ Codegen | SDF | Finishing generation of Signature for [<pp-aterm> module-untyped-qname].]
			
	
rules 

	// TODO: use concrete syntax for signatures?
	
	// Instead of using String interpolation, Generate the default signatures
	// using global contructor defined during init-declartion   
	
	// TODO : OPTMIZE : add a pretty printer to convert operation name DR to STR Signatures. 
	// Currently , using string interpolation, signature are generated . then it is reparsed to
	// to convert it to aterm. Get rid of this. 
	
	get-signature-contents(|moduleName,imports): signatures-string* ->
$[module [moduleName]

[imports]
signature
    constructors
       [<concat-strings>signatures-string*]
]  
	
    	
	get-all-signatures-as-string(s) = all-keys-Get-Operation-Signature; filter(s); mapconcat(bagof-Get-Operation-Declaration);operation-decl-to-string
  
  operation-decl-to-string : [] -> []
  
  operation-decl-to-string : 
  	[first-op-decl | rest-op-decl* ]->[current-op-decl-string | rest-op-decl-string*]
  	where 
  		(opname, operands*, resultant-sort) := first-op-decl
  		;if (!operands* => []) then
	  		current-op-decl-string := $[[<opname-to-string>opname]: [resultant-sort]
	  		]
  		else
  			current-op-decl-string := $[[<opname-to-string>opname]: [<lhs-operands-to-string>operands*] -> [resultant-sort]
  			]
  			
  		end		 
  		;rest-op-decl-string* := <operation-decl-to-string> rest-op-decl* 
 	
 	
 	opname-to-string : opname -> opname-string
 	where 
 		if (!opname => "") then 
 			opname-string := $[]
		else
			opname-string  := opname
		end
				
  //TODO : generalize following strategies. 
  lhs-operands-to-string : [] -> $[]
  
  lhs-operands-to-string : [last] -> $[[last]]
   
  lhs-operands-to-string : [hd-operand|rest*] -> $[[hd-operand-string] * [rest-operand-string]]
  where
  	not (![] => rest*) 
  where 
  	 hd-operand-string := hd-operand 
  	;rest-operand-string := <lhs-operands-to-string>rest*
  	  