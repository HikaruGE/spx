module codegen/esv/to-esv
imports
	libstratego-lib
	include/libtemplatelang
imports
  common
  config
  utils/debug
  utils/path
  utils/contract
imports
  normalize/main
	normalize/signatures
	include/SpoofaxLang
imports
	codegen/main
	codegen/generate
	context/-
imports
	lib/editor-common.generated


signature constructors
  Module : ID * Imports * List(Section) -> Module

rules 

	get-esv-sections =
		verify(?p@Package(QName(_)) | <id> , "Package(QName(_)) @get-esv-sections"); 
		esv-sections-of-current-package* := <resolve-all-symbol-definitions>(<id> , ESVSection()) ;
		<get-all-usings> p ;  
		filter(?Package(_)); //getting all the imported packages
		mapconcat(
			{ ?package-qname;
				activate-scope(
					<resolve-all-symbol-definitions>(<id> , ESVSection())  
			  	| package-qname 
			  );
			  // not adding following sections in ESV 
			  filter(
			  	not( 
			  		?Language(_,_)  
		  		+ ?Builders(_,_) 
	  			+ ?References(_,_))
			  	)
		  }
		) => esv-sections-from-imported-package*;
		<conc>( esv-sections-of-current-package*  ,  esv-sections-from-imported-package*)
	
rules

	/**
	* Packs all the esv definitions for the namespace and combine them as a
	* single *.main.packed.esv and store it in .shadow dir
	*
	* OPTIMIZATION : If we allow arbitary order of different sections of ESV ,
	*								then we can avoid store-esv-definitions .
	*/
	generate-esv-main: 
		module-qname'* -> <id>
		where
			with-spxverify(	
		 		project-path             := <ProjectPath>;
		 		Package(package-qname)   := <GetEnclosingPackageName>,
		 		!" Failed to get current-project-path or enclosing package name @generate-esv-main"
		 	)
 			; dbg-compiler(!$[CodeGen | ESV | Generate-esv-main  : [<print-as-string>package-qname]])
			; with-spxverify(
		 			 relative-autogen-path := <qname-to-path>package-qname
		 			; package-esv-main-name := $[[<get-main-file-name><GetEnclosingPackageName> ].main.packed]
		 			; autogen-dir           := $[[<get-autogenerated-artifacts-dir>]/[relative-autogen-path]]
		 			; root-directory 			 := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
 			 	)
 		where with-spxverify(
 			// getting all the indexed esv sections from the semantic index for the current package 
 			// During Esv generation, imported packages is also packed.
 			// Design Issue: transitive imports is not supported.
 			//--------------------------------------------------------------------
 			<get-esv-sections>Package(package-qname) => esv-sections*;
 			<conc>(	 
 				<inject-package-ctree><get-main-file-name><GetEnclosingPackageName>,   // adding ctree import by default
	 			<inject-table-definition><get-main-file-name><GetEnclosingPackageName>,   // default table definition
	 			esv-sections*
	 	 	);
	 	 	if templatelang-enabled then  
	 	 		debug(!"inside template language enabled");
	 	 		get-templatelang-specific-esv-sections(|<GetEnclosingPackageName>,module-qname'*)// Performing templatelang related transformations   
 			end
 			; ensure-lang-id-added(|<GetEnclosingPackageName>)
 			; esv-aterm := Module(package-esv-main-name, Import([]), <id>) // Final esv-aterm
 			; <save-artifact(WriteToBinaryFile | package-qname , root-directory , <get-main-output-path(|$[[<get-main-file-name><GetEnclosingPackageName>].main], "esv")>(root-directory , package-qname))>esv-aterm
			; dbg-compiler(!$[$[$Codegen | ESV |$]$ Finished generation of packed esv for [<print-as-string>package-qname]])
			, !"Failed to generate ESV main"
		)
	
	
	get-templatelang-specific-esv-sections(|package-id,module-qname'*) =
			?sections;
			if templatelang-enabled then
 				//modules to consider for creating packed.esv
				<get-all-imported-modules>package-id  => imported-modules*;
				<conc;make-set>( module-qname'* , imported-modules*) => module-qname*; 
        <conc>(<map(get-original-module-definition; ?Module(_, _, <templatelang-desugar-top; template-sections-to-esv>))> module-qname* ,  sections)
 			else
 				!sections
 			end

	ensure-lang-id-added(|package-id) =
		?sections;
		// Adding language Id if not already added with language description
		if <get-language-id>package-id then 
			<filter(not(?[]))>sections 
		else
			default-lang-id := <get-default-language-id> package-id;
			lang-id-esv-section := [Language("Language Id Definition" , [LanguageId(default-lang-id)])];
			<conc;filter(not(?[]))>(sections , lang-id-esv-section)
		end
 	
 	//Adding package ctree as the default semantic provider0
	inject-package-ctree :
		lang-name -> [Builders("",[SemanticProvider(lang-output-ctree)])]
		where
				lang-output-ctree := $[include/[lang-name].ctree]


	// Injects the default table definition in ESV definition.
	inject-table-definition :
		lang-name -> [Language("Default Table Specifiaction" , [default-table-def])]
		where
			default-table-def := Table($[include/[lang-name].tbl])

rules

	/**
	* Converts ( package-name , concept-name) to stratego import
	*
	* @type ( package-name, concept-name) -> Import(name)
	*/
	to-esv-import:
		Module(q@QName(qnameparts*))->Import(esv-import)
		where
			esv-import:= <qname-to-path>q

 	