module codegen/esv/to-esv
imports
	libstratego-lib
	libstrc
imports
  common
  config
  utils/debug
  utils/path
imports
  normalize/main
	normalize/signatures
	include/SpoofaxLang
imports
	codegen/main
	codegen/generate
	codegen/template/to-esv
	context/-
imports
	lib/editor-common.generated


signature constructors
  Module : ID * Imports * List(Section) -> Module

rules

	/**
	* Packs all the esv definitions for the namespace and combine them as a
	* single *.main.packed.esv and store it in .shadow dir
	*
	* OPTIMIZATION : If we allow arbitary order of different sections of ESV ,
	*								then we can avoid store-esv-definitions .
	*/
	generate-esv-main: module-qname'* -> <id>
		with
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>
 		where
			<debug-compiler>$[CodeGen | ESV | Generate-esv-main  : [<pp-aterm>package-qname]]
		with
 			 relative-autogen-path := <qname-to-path>package-qname
 			;package-esv-main-name := $[[<get-main-file-name>()].main.packed]
 			;autogen-dir           := $[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
 			;root-directory 			 := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
 		where
 			// During Esv generation, imported packages is also packed.
 			// Note: transitive imports is not supported.
 			<get-all-imported-modules>Package(package-qname) => imported-modules*;
 			<conc;make-set>( module-qname'* , imported-modules*) => module-qname*; 
 			{|  //TODO : consider removing DR and use collect instead
 					Declared-Language-Description,Declared-Builders-Description,Declared-Colorer-Description,
 					Declared-Folding-Description,Declared-Outliner-Description,Declared-References-Description,
 					Declared-Completions-Description:
 						<map(store-module-esv-definition)>module-qname*
 						;sections := <conc>
 						 					(	 <inject-package-ctree><get-main-file-name>(),   // adding ctree import by default
	 						 					 <inject-table-definition><get-main-file-name>(),   // default table definition
	 						 					 //<inject-language-id><get-language-id> Package(package-qname),
	 						 					 <all-keys-Declared-Language-Description>,
	 			 								 <all-keys-Declared-Builders-Description> ,
	 			 								 <all-keys-Declared-Colorer-Description> ,
	 			 								 <all-keys-Declared-Folding-Description>,
	 			 								 <all-keys-Declared-Outliner-Description>,
	 			 								 <all-keys-Declared-References-Description>,
	 			 								 <all-keys-Declared-Completions-Description>,
	 			 								 <map(get-original-module-declaration; template-module-to-esv)> module-qname*
 			 							   )
 			|};
 			// Adding language Id if not already added with language description
 			if <oncetd(?LanguageId(langid))>sections then
 				sections' := <filter(not(?[]))>sections 
 			else
 				sections' := <conc;filter(not(?[]))>(sections , <inject-language-id><get-language-id> Package(package-qname))
 			end
 			;esv-aterm := Module(package-esv-main-name, Import([]), sections')
 			;<debug-compiler> $[$[$ Codegen | Packed ESV |$]$ [<pp-aterm>esv-aterm]]  
 			;<save-artifact(WriteToBinaryFile | package-qname , root-directory , <get-main-output-path(|$[[<get-main-file-name>()].main], "esv")>(root-directory , package-qname))>esv-aterm
		where
			<debug-compiler>$[$[$Codegen | ESV |$]$ Finished generation of packed esv for [<pp-aterm>package-qname].]

	store-module-esv-definition : Module(QName(untyped-module-qname)) -> <id>
	where
		<debug> $[CodeGen | ESV |  Packing following module : [<pp-aterm>QName(untyped-module-qname)]] 
	where 
		get-original-module-declaration;
 		store-esv-defintions
 		
	inject-language-id : 
		lang-id -> [Language("Language Id Definition" , [LanguageId(lang-id)])]
		
	//Adding package ctree as the default semantic provider0
	inject-package-ctree :
		lang-name -> [Builders("",[SemanticProvider(lang-output-ctree)])]
		where
				lang-output-ctree := $[include/[lang-name].ctree]


	// Injects the default table definition in ESV definition.
	inject-table-definition :
		lang-name -> [Language("Default Table Specifiaction" , [default-table-def])]
		where
			default-table-def := Table($[include/[lang-name].tbl])


	//Returns all the imports for the current namespace.
 	get-all-imports =
 		?mod-qname*
 		;import-decl* := <map(to-esv-import) ; flatten-list ;	make-set> mod-qname*
 		;!Imports(import-decl* )

rules

	/**
	* Converts ( package-name , concept-name) to stratego import
	*
	* @type ( package-name, concept-name) -> Import(name)
	*/
	to-esv-import:
		Module(q@QName(qnameparts*))->Import(esv-import)
		where
			esv-import:= <qname-to-path>q


rules

 	/**
 	* Storing different Esv language definitions so that it can be
 	* combined in *.main.packed.esv in a particular order
 	*/
 	store-esv-defintions:
 		 m@Module(attrb* , modname , section*) -> m
		 with
		 	<alltd(store-esv-def)> section*


 	// Storing Esv Definitions that specifies Langauge
 	store-esv-def :
 		l@Language(_,_) -> l
 		with
 			rules ( Declared-Language-Description :+ l -> l)



 	/**
 	* Storing Esv Definitions that specifies the builders for the
 	* language definition.
 	*/
 	store-esv-def: 
 		b@Builders(_,_) -> b
 		with
 			rules ( Declared-Builders-Description :+ b -> b)

 	/**
 	* Storing Esv Definitions that specifies the colorer for the
 	* language definition.
 	*/
 	store-esv-def : c@Colorer(_,[_|_]) -> c
 		with
 			rules ( Declared-Colorer-Description :+ c -> c)

 	/**
 	* Storing Esv Definitions that specifies the folding semantics for the
 	* language definition.
 	*/
 	store-esv-def: 
 		f@Folding(_,_) -> f
 		with
 			rules ( Declared-Folding-Description :+ f -> f)

 	/**
 	* Storing Esv Definitions that specifies the outliner for the
 	* language definition.
 	*/
 	store-esv-def : 
 		o@Outliner(_,_) -> o
 		with
 			rules ( Declared-Outliner-Description :+ o -> o)
 	/**
 	* Storing Esv Definitions that specifies the code completion
 	* for the language definition.
 	*/
 	store-esv-def : 
 		c@Completions(_,_) -> c
 		with
 			rules ( Declared-Completions-Description:+ c -> c)

 	/**
 	* Storing Esv Definitions that specifies the refencen resolving constructs
 	* for the language definition.
 	*/
 	store-esv-def : 
 		r@References(_,_) -> r
 		with
 			rules ( Declared-References-Description :+ r -> r)

 	/*
 	* optimization - ignores following section that are not relevant to the current computations.
 	*		a] str sections
 	*		b] sdf sections
 	*   c] template sections
 	*/
 	store-esv-def : s@SDFSection (_) -> s //Do nothing

 	store-esv-def : s@SDFSectionEH (_,_) -> s //Do nothing

 	store-esv-def : s@STRSection (_) -> s //Do nothing

  store-esv-def : s@TemplateSection(_) -> s //Do nothing
