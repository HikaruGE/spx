module codegen/esv/to-esv
imports 
	libstratego-lib
	libstrc
imports
  common
  config
  utils/debug
  utils/path
imports 
	normalize/signatures 
	include/SpoofaxLang
imports 
	codegen/main 
	context/scope-tree 
	context/signature
imports
	lib/editor-common.generated

	
signature constructors 
  Module : ID * Imports * List(Section) -> Module
	
rules 

	/**
	* Packs all the esv definitions for the namespace and combine them as a 
	* single *.main.packed.esv and store it in .showdow dir
	* 
	* OPTIMIZATION : If we allow arbitary order of different sections of ESV , 
	*								then we can avoid store-esv-definitions .
	*/
	generate-esv-main: module-qname* -> <id>
		with 
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>
 		where 
			<debug-compiler>$[codegen | ESV | generate-esv-main  : [<pp-aterm>package-qname]]
		with	 
 			 relative-autogen-path :=  <qname-to-path>package-qname
 			;package-esv-main-name := $[[<convert-qname(|"-")>package-qname].main.packed]
 			;autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
 		where 
 			{|  Declared-Language-Description,Declared-Builders-Description,Declared-Colorer-Description,
 					Declared-Folding-Description,Declared-Outliner-Description,Declared-References-Description,
 					Declared-Completions-Description:
						//TODO  : Q>> why do we need imports in main.packed.esv  ?
 						<map(get-original-module-declaration;store-esv-defintions)>module-qname*
 						;sections := <conc>(<add-package-ctree>(<qname-to-string>package-qname),   // adding ctree import by default
 						 					<all-keys-Declared-Language-Description>, 
 			 								<all-keys-Declared-Builders-Description> ,  
 			 								<all-keys-Declared-Colorer-Description> , 
 			 								<all-keys-Declared-Folding-Description>,
 			 								<all-keys-Declared-Outliner-Description>,
 			 								<all-keys-Declared-References-Description>,
 			 								<all-keys-Declared-Completions-Description>
 			 							   )
 			|} 
 			//;esv-aterm := Module(package-esv-main-name, <get-all-imports>module-qname*, sections) 
 			;esv-aterm := Module(package-esv-main-name, Import([]), sections) 
		where 
			<debug-compiler>$[codegen | ESV | Creating content for the ESV Main of package [<pp-aterm>package-qname]. ]	  
 		where
 			// Saving the content to a file . 	
			autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;<ensure-exists>(autogen-root-directory , package-qname)
			//TODO : create a consistent namming for the file name + move it to lib 
			;output-path := <get-main-esv-output-path(|"esv")>(autogen-root-directory , package-qname)   
			;<WriteToBinaryFile>(output-path ,esv-aterm)
			;<refresh-workspace-file>output-path
			;chdir-to-project-path
		where
			<debug-compiler>$[ Codegen | ESV | Finishing generation of packed esv for [<pp-aterm>package-qname].]
		 		
	
	/*
	* Adding package ctree as the default semantic provider0
	* 
	* @type packagename -> default semantic provider 
	*/
	add-package-ctree : package-name -> [SemanticProvider(package-output-ctree)] // TODO : get main package ctree
		where 
				package-output-ctree := $[include/[package-name].ctree]
	
	/*
	* Returns all the imports for the current namespace. 
	*/
 	get-all-imports = 
 		?mod-qname*
 		;import-decl* := <map(to-esv-import) ; flatten-list ;	make-set> mod-qname*
 		;!Imports(import-decl* ) 		
	 		
rules
	
	/**
	* Converts ( package-name , concept-name) to stratego import
	* 
	* @type ( package-name, concept-name) -> Import(name) 
	*/		
	to-esv-import:  
		Module(q@QName(qnameparts*))->Import(esv-import)
		where 
			esv-import:= <qname-to-path>q
	
 
rules			   
 	
 	/**
 	* Storing different Esv langauge definitions so that it can be 
 	* combined in *.main.packed.esv in a particular order 
 	*/
 	store-esv-defintions:
 		 m@Module(attrb* , modname , section*) -> m
		 with
		 	<alltd(store-esv-def)> section* 
 
 	/**
 	* Storing Esv Definitions that specifies Langauge 
 	*/
 	store-esv-def : l@Language(_,_) -> l
 		with 
 			rules ( Declared-Language-Description :+ l -> l)
 	
 	/**
 	* Storing Esv Definitions that specifies the builders for the 
 	* langauge definition. 
 	*/
 	store-esv-def : b@Builders(_,_) -> b
 		with 
 			rules ( Declared-Builders-Description :+ b -> b) 
 	
 	/**
 	* Storing Esv Definitions that specifies the colorer for the 
 	* langauge definition. 
 	*/
 	store-esv-def : c@Colorer(_,_) -> c
 		with 
 			rules ( Declared-Colorer-Description :+ c -> c) 
 	
 	/**
 	* Storing Esv Definitions that specifies the folding semantics for the 
 	* langauge definition. 
 	*/
 	store-esv-def : f@Folding(_,_) -> f
 		with 
 			rules ( Declared-Folding-Description :+ f -> f)
 	
 	/**
 	* Storing Esv Definitions that specifies the outliner for the 
 	* langauge definition. 
 	*/		
 	store-esv-def : o@Outliner(_,_) -> o
 		with 
 			rules ( Declared-Outliner-Description :+ o -> o)
 	/**
 	* Storing Esv Definitions that specifies the code completion
 	* for the langauge definition. 
 	*/
 	store-esv-def : c@Completions(_,_) -> c
 		with 
 			rules ( Declared-Completions-Description:+ c -> c)
 	
 	/**
 	* Storing Esv Definitions that specifies the refencen resolving constructs
 	* for the langauge definition. 
 	*/
 	store-esv-def : r@References(_,_) -> r
 		with 
 			rules ( Declared-References-Description :+ r -> r)
 	
 	/*
 	* optimization - ignores following section that are not relevant to the current computations.
 	*		a] str sections
 	*		b] sdf sections
 	*/
 	store-esv-def : s@SDFSection (_) -> s //Do nothing
 	
 	store-esv-def : s@SDFSectionEH (_,_) -> s //Do nothing
 	
 	store-esv-def : s@STRSection (_) -> s //Do nothing
 	 
 	
 	 