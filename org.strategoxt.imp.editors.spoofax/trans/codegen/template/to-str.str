// FIXME: Refactor to use lists, and separate-by(|"\n") to insert newlines.
//        Then we can get rid of the four (!) pp-ih-* strategies.
//        [Layout, Placeholder] could just generate an empty tuple for an
//        empty substitute, which could be filtered out later on...
//
// 1. template-line-to-stratego
// 2. filter(not(?()))
// 3. separate-by(|"\n")
// 4. concat

module to-str

imports
  libstratego-lib
  libstrc
  include/SpoofaxLang
imports
  context/str/parse
  context/template/declare
  normalize/templatelang
  utils/attributes
  utils/sdf2conflicts
  utils/templatelang

strategies

  test-templatelang-to-str:
    ast -> result
    with
      init-template-options;
      <?CompilationUnit([], [Package(_, [Module(_, SPXModuleName(modulename), sections)])])> ast;
      (options, t-sections) := <partition(?TemplateOptions(<id>))> sections;
      <try([declare-template-options-main])> options;
      <template-sections-to-stratego; alltd(Str(templatelang-escape; double-quote))> t-sections => result

strategies

  template-sections-to-stratego =
    template-sections-to-stratego-string;
    parse-stratego-string;
    alltd(try(un-double-quote); unescape)

  template-sections-to-stratego-string:
    section* ->
    ${module prettyprinter
      imports
        libstratego-lib

      strategies

        pp-option(s) = \None() -> ""\ + \Some(t) -> <s> t\
        pp-list(s|t) = map(s); separate-by(|t); concat-strings
        // ih = indent helper, t = indent string
        pp-ih-0(|t) = ?"" <+ prefix-lines(|t)
        pp-ih-1(|t) = ?"" <+ prefix-lines(|t); <conc-strings> (<id>, "\n")
        pp-ih-2(|t) = ?"" <+ prefix-lines(|t); <conc-strings> ("\n", <id>)
        pp-ih-3(|t) = ?"" <+ prefix-lines-except-first(|t)

        all-lines-except-first(s) =
            is-string
          ; string-tokenize-keep-empty(|['\n'])
          ; at-last( \ [""] -> [] \  // Do not run s on a final empty line.
                   < where(!["\n"] => laststring) // ... but remember that the second last line was delimited by a newline
                   + where(![] => laststring))    // ... or not.
          ; ([id | map(s)] + [])
          ; <separate-by> ("\n", <id>)
          ; <conc> (<id>, laststring) // Restore the final newline, if there was one.
          ; concat-strings

        prefix-lines-except-first(|p) =
          all-lines-except-first(<conc-strings> (p, <id>))

      {section''*}

      strategies // all other sorts used in placeholders

        {strategy*}}
    with
      section'*  := <templatelang-desugar-top> section*;
      section''* := <filter(template-section-to-stratego-string);
                     separate-by(|"\n\n")> section'*
    with
      // All sorts used in pp minus all sorts for which a pp strategy has been
      // created will get a `prettyprint-sort = is-string' default strategy.
      sorts-used-in-pp := <collect-om(sort-used-in-prettyprinting); nub> section'*; // FIXME: global data
      sorts-decl-in-pp := <collect-om(sort-decl-in-prettyprinting); nub> section'*; // FIXME: global data
      sorts-without-pp := <diff> (sorts-used-in-pp, sorts-decl-in-pp);
      strategy* := <map(sort-to-prettyprint-strategy); separate-by(|"\n\n")> sorts-without-pp

  template-section-to-stratego-string:
    TemplateSection(prod*) ->
    $[strategies

        [strategy*]]
    with
      strategy* := <declare-template-definition-main;
                    map(template-to-prettyprint-strategy);
                    separate-by(|"\n\n")> prod*

/*internal*/ strategies

  sort-to-prettyprint-strategy:
    sort -> $[prettyprint-[sort] = is-string]

  sort-decl-in-prettyprinting:
    TemplateProduction(sort, _, _) -> sort

  sort-used-in-prettyprinting:
    Placeholder(sort(sort), _, _) -> sort

rules

  // Single line template with only Layout and String elements.
  template-to-prettyprint-strategy:
    TemplateProduction(sort, SingleLineTemplate(elem*), attrs) ->
    $[prettyprint-[sort]:
        [cons]() -> "[<templatelang-escape> t]"]
    where
      [String(t)] := <map(\Layout(t) -> String(t)\ + ?String(_));
                      concatenate-consecutive-strings> elem*;
      cons := <fetch-cons-name> attrs

  // Template with only a placeholder. (i.e., injection)
  // The placeholder is at the start AND at the end of the template!
  template-to-prettyprint-strategy:
    TemplateProduction(sort, template, attrs) ->
    $[prettyprint-[sort]:
        [input] -> a'
        where
          [<template-element-to-prettyprint> p{"a"}]]
    where
      < ?SingleLineTemplate([p @ Placeholder(_, _, _)])
      + ?Template([Line([Layout(_), p @ Placeholder(_, _, _)])]) > template
    with
      if cons := <fetch-cons-name> attrs then
        input := $[[cons](a)]
      else
        input := "a"
      end

  // Generalized injection: a list of placeholder lines only.
  // This means that there is no place where
  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(line*), attrs) ->
    $[prettyprint-[sort]:
        [input] -> zz
        where
          [let'*]]
    where
      <all(?Line([Layout(_), Placeholder(_, _, _)]))> line*;
      not(!line* => [_]) // normal injection
    with
      (line'*, _)    := <thread-map(rename-template-line)> (line*, 0);
      (line''*, _)   := <thread-map(template-line-to-stratego)> (line'*, -1);
      arg*           := <mapconcat(template-line-to-cons-arg)> line'*;
      let*           := <mapconcat(template-line-to-prettyprint)> line'*;
      (input, let'*) := <template-common> (let*, <separate-by(|["\"\\n\""]); concat> line''*, attrs, arg*)

  template-to-prettyprint-strategy:
    TemplateProduction(sort, SingleLineTemplate(elem*), attrs) ->
    $[prettyprint-[sort]:
        [input] -> zz
        where
          [let'*]]
    where
      not(<map(?Layout(_) + ?String(_))> elem*);
      not(!elem* => [Placeholder(_, _, _)])
    with
      (elem'*, _)    := <thread-map(try(rename-template-element))> (elem*, 0);
      elem''*        := <map(template-element-to-stratego(|""))> elem'*;
      arg*           := <filter(template-element-to-cons-arg)> elem'*;
      let*           := <filter(template-element-to-prettyprint)> elem'*;
      (input, let'*) := <template-common> (let*, elem''*, attrs, arg*)

  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(line*), attrs) ->
    $[prettyprint-[sort]:
        [input] -> zz
        where
          [let'*]]
    with
      (line'*, _)    := <thread-map(rename-template-line)> (line*, 0);
      (line''*, _)   := <thread-map(template-line-to-stratego)> (line'*, 0);
      arg*           := <mapconcat(template-line-to-cons-arg)> line'*;
      let*           := <mapconcat(template-line-to-prettyprint)> line'*;
      (input, let'*) := <template-common> (let*, <concat> line''*, attrs, arg*)

  template-common:
    (let*, elem*, attrs, arg*) -> (input, let'*)
    where
      part*  := <concatenate-consecutive-strings;
                 map(try(?String(<templatelang-escape; double-quote>)));
                 separate-by(|",")> elem*;
      result := <concat-strings>["zz := <concat-strings> [", part*, "]"];
      let'*  := <separate-by(|";\n")> [let*, result]
    where
      if cons := <fetch-cons-name> attrs then
        input := $[[cons]([<separate-by(|",")> arg*])]
      else
        if !arg* => [_] then
          input := "a"
        else
          input := $[([<separate-by(|",")> arg*])]
        end
      end

  // FIXME
  // Production without cons but with bracket annotation
  // (cons + bracket -> no need to parenthesize)
  // template-to-prettyprint-strategy:
  //   TemplateProduction(sort, Template(elem*), attrs) ->
  //   ${parenthesize-{sort}(not-allowed) =
  //       if not-allowed then
  //         <concat-strings> ["{open}", <prettyprint-{sort}>, "{close}"]
  //       else
  //         prettyprint-{sort}
  //       end}
  //   where
  //     not(<fetch-cons-name> attrs);
  //     FIXME <getfirst(?bracket())> attr*
  //   where
  //     <length> <filter(?Placeholder(_, _, _))> elem* => 1
  //     <+ debug(!"Bracket production must have exactly one placeholder: "); fail
  //   with
  //     (before, placeholder, after) := <split-fetch-keep(?Placeholder(_, _, _))> elem*
  //   where
  //     [String(open)]  := <map(template-element-to-stratego'); concatenate-consecutive-strings> before;
  //     [String(close)] := <map(template-element-to-stratego'); concatenate-consecutive-strings> after
  //     <+ debug(!"Bracket production must have text before and after the placeholder: "); fail

rules

  rename-template-line:
    (Line(elem*), index) -> (Line(elem'*), index')
    with
      (elem'*, index') := <thread-map(try(rename-template-element))> (elem*, index)

  rename-template-element:
    (Placeholder(a, b, c), index) -> (Placeholder(a, b, c){name'}, index')
    with
      name'  := <implode-string> [<addi> ('a', index)];
      index' := <inc> index

rules

  template-line-to-cons-arg:
    Line(elem*) -> <filter(template-element-to-cons-arg)> elem*

  template-element-to-cons-arg:
    Placeholder(_, _, _){name} -> name

rules

  // template-line-to-stratego is to be used with thread map.
  // The thread starts at 0 and is set to 1 once we passed the first line.
  // It is used to determine whether we already generated the initial newline.

  // Or: it is set to -1 and stays at -1, this means there are only
  //     placeholders in the template, so none needs to add a newline.

  template-line-to-stratego:
    (Line([Layout(indent), Placeholder(_, _, _){name}]), -1) ->
      ([$[<pp-ih-0(|"[indent]")> [name]']], -1)

  template-line-to-stratego:
    (Line([Layout(indent), Placeholder(_, _, _){name}]), 0) ->
      ([$[<pp-ih-1(|"[indent]")> [name]']], 0)

  template-line-to-stratego:
    (Line([Layout(indent) | elem*]), 0) -> (elem'*, 1)
    where
      not(!elem* => [Placeholder(_, _, _)]);
      elem'* := <map(template-element-to-stratego(|indent))> elem*

  template-line-to-stratego:
    (Line([Layout(indent), Placeholder(_, _, _){name}]), 1) ->
      ([$[<pp-ih-2(|"[indent]")> [name]']], 1)

  template-line-to-stratego:
    (Line([Layout(indent) | elem*]), 1) -> ([String("\n") | elem'*], 1)
    where
      not(!elem* => [Placeholder(_, _, _)]);
      elem'* := <map(template-element-to-stratego(|indent))> elem*

  template-element-to-stratego(|indent):
    String(t) -> <id>

  template-element-to-stratego(|indent):
    Layout(t) -> String(t)

  template-element-to-stratego(|indent):
    Placeholder(_, _, _){name} -> $[[s][name]']
      where
        if !indent => "" then
          s := ""
        else
          s := $[<pp-ih-3(|"[indent]")> ]
        end

rules

  template-line-to-prettyprint:
    Line(elem*) -> <filter(template-element-to-prettyprint)> elem*

  template-element-to-prettyprint:
    Placeholder(sort(x), None(), _){name} -> $[[name]' := <prettyprint-[x]> [name]]

  template-element-to-prettyprint:
    Placeholder(sort(x), <Star() + Plus()>, option*){name} -> t
    with
      if sep := <getfirst(?Separator(<id>))> option* then
        t := $[[name]' := <pp-list(prettyprint-[x]|"[<templatelang-escape> sep]")> [name]]
      else
        t := $[[name]' := <pp-list(prettyprint-[x]|" ")> [name]]
      end

  template-element-to-prettyprint:
    Placeholder(sort(x), Option(), _){name} -> $[[name]' := <pp-option(prettyprint-[x])> [name]]

rules

//   template-element-to-parenthesize(|conflicts):
//     (i0, Placeholder(sort(x), None(), _){name}) -> $[[name]' := <parenthesize-[x]([na])> [name]]
//     where
//       not(<filter(?(i0, <id>))> conflicts => conflicts' => [])
//     with
//       let to-match =
//             {a*: \ Symbol(x, n) -> <concat-strings> ["?", x, "(", a*, ")"]
//                    with a* := <range; map(!"_"); separate-by(|", ")> (0, n) \}
//       in
//         na := <filter(to-match); separate-by(|" + ")> conflicts'
//       end
//
//   template-element-to-parenthesize(|conflicts):
//     (i0, p@ Placeholder(sort(x), None(), _){name}) -> <template-element-to-prettyprint> p
//     where
//       <filter(?(i0, _))> conflicts => []
//
//   template-element-to-parenthesize(|conflicts):
//     (i0, p@ Placeholder(sort(x), <not(?None())>, _){name}) -> <template-element-to-prettyprint> p
