module to-str

imports
  libstratego-lib
  libstrc
  include/SpoofaxLang
imports
  context/str/parse
  context/template/declare
  normalize/templatelang
  utils/sdf2conflicts
  utils/templatelang

strategies

  test-templatelang-to-str:
    (_, _, ast, _, _) -> result
    with
      init-template-options;
      <?CompilationUnit([], [Package(_, [Module(_, SPXModuleName(modulename), sections)])])> ast;
      (options, t-sections) := <partition(?TemplateOptions(<id>))> sections;
      <try([declare-template-options-main])> options;
      <template-sections-to-stratego; alltd(Str(escape; double-quote))> t-sections => result

strategies

  template-sections-to-stratego =
    template-sections-to-stratego-string;
    parse-stratego-string;
    alltd(try(un-double-quote); unescape)

  template-sections-to-stratego-string:
    section* ->
    $[module prettyprinter
      imports
        libstratego-lib

      strategies

        pp-option(s) = \None() -> ""\ + \Some(t) -> <s> t\
        pp-list(s|t) = map(s); separate-by(|t); concat-strings
        pp-guarantee-newline = string-ends-with(|"\n") <+ <conc-strings> (<id>, "\n")
        // ih = indent helper, t = indent string
        pp-ih(|t) = ?"" <+ prefix-lines(|t); pp-guarantee-newline

      [section''*]

      strategies // all other sorts used in placeholders

        [strategy*]]
    with
      section'*  := <templatelang-desugar-top> section*;
      section''* := <filter(template-section-to-stratego-string);
                     separate-by(|"\n\n")> section'*
    with
      // All sorts used in pp minus all sorts for which a pp strategy has been
      // created will get a `prettyprint-sort = is-string' default strategy.
      sorts-used-in-pp := <collect-om(sort-used-in-prettyprinting); nub> section'*; // FIXME: global data
      sorts-decl-in-pp := <collect-om(sort-decl-in-prettyprinting); nub> section'*; // FIXME: global data
      sorts-without-pp := <diff> (sorts-used-in-pp, sorts-decl-in-pp);
      strategy* := <map(sort-to-prettyprint-strategy); separate-by(|"\n\n")> sorts-without-pp

  template-section-to-stratego-string:
    TemplateSection(prod*) ->
    $[strategies

        [strategy*]]
    with
      strategy* := <declare-template-definition-main;
                    map(template-to-prettyprint-strategy);
                    separate-by(|"\n\n")> prod*

/*internal*/ strategies

  sort-to-prettyprint-strategy:
    sort -> $[prettyprint-[sort] = is-string]

  sort-decl-in-prettyprinting:
    TemplateProduction(sort, Template(_), _) -> sort

  sort-used-in-prettyprinting:
    Placeholder(_, sort(sort), _, _) -> sort

  // Optimization for single-string-element templates
  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template([String(t)]), attrs(attr*)) ->
    $[prettyprint-[sort]:
        [cons]() -> "[result]"]
    where
      cons   := <getfirst(?sdf-cons(<un-double-quote>))> attr*
    with
      result := <templatelang-escape> t

  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(elem*), attrs(attr*)) ->
    <trim-chars(' ' + '\t' + '\r' + '\n')> // Workaround Stratego/856
    $[prettyprint-[sort]:
        [cons]([arg'*]) -> zz
        with
          [let'*]]
    where
      not(!elem* => [String(_)])
    where
      cons    := <getfirst(?sdf-cons(<un-double-quote>))> attr*
    with
      elem'*  := <try-re-indent;
                  !(<id>, 0);
                  thread-map(try(rename-template-element));
                  ?(<id>, _)> elem*;
      arg*    := <filter(template-element-to-cons-arg)> elem'*;
      arg'*   := <separate-by(|", ")> arg*;
      part*   := <try(\[Newline(_) | tail] -> tail\); // strip first newline, but KEEP INDENT!
                  // FIXME: might want to replace Newline,Indent with Newline, thereby
                  //        making multi-line templates implicitly newline-separated.
                  try(at-suffix(\[Newline(t), Indent(_)] -> [/*Newline(t)*/]\)); // strip last newline
                  trim-trailing-layout;
                  listtd(template-element-to-stratego);
                  concatenate-consecutive-strings;
                  map(try(?String(<templatelang-escape; double-quote>)));
                  separate-by(|", ")> elem'*;
      result  := <concat-strings>["zz := <concat-strings> [", part*, "]"];
      confl*  := <bagof-SubtermConflicts> Symbol(cons, <length> arg*);
      // if !confl* => [] then
        let*  := <filter(template-element-to-prettyprint)> elem'*;
      // else
      //   let*  := <filter(?Placeholder(_, _, _, _));
      //             add-indices; map((dec, id));
      //             filter(template-element-to-parenthesize(|confl*))> elem'*
      // end;
      let'*   := <separate-by(|";\n")> [let*, result]

  // Injection (no cons, no bracket, exactly one placeholder)
  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(elem*), attrs(attr*)) ->
    $[prettyprint-[sort]:
        a -> a'
        where
          [let']]
    where
      not(<getfirst(?sdf-cons(<un-double-quote>))> attr*);
      not(<getfirst(?bracket())> attr*)
    where
      <one(?Placeholder(w, x, y, z))> elem*
    with
      let' := <template-element-to-prettyprint> Placeholder(w, x{"a"}, y, z)

  // Production without cons but with bracket annotation
  // (cons + bracket -> no need to parenthesize)
  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(elem*), attrs(attr*)) ->
    ${parenthesize-{sort}(not-allowed) =
        if not-allowed then
          <concat-strings> ["{open}", <prettyprint-{sort}>, "{close}"]
        else
          prettyprint-{sort}
        end}
    where
      not(<getfirst(?sdf-cons(<un-double-quote>))> attr*);
      <getfirst(?bracket())> attr*
    where
      <length> <filter(?Placeholder(_, _, _, _))> elem* => 1
      <+ debug(!"Bracket production must have exactly one placeholder: "); fail
    with
      (before, placeholder, after) := <split-fetch-keep(?Placeholder(_, _, _, _))> elem*
    where
      [String(open)]  := <map(template-element-to-stratego'); concatenate-consecutive-strings> before;
      [String(close)] := <map(template-element-to-stratego'); concatenate-consecutive-strings> after
      <+ debug(!"Bracket production must have text before and after the placeholder: "); fail

  rename-template-element:
    (Placeholder(a, b@ sort(x), c, d){a*}, index) -> (Placeholder(a, b{newname}, c, d){a*}, newindex)
    with
      newname  := <implode-string> [<addi> ('a', index)];
      newindex := <inc> index

  template-element-to-cons-arg:
    Placeholder(_, sort(_){name}, _, _) -> name

  template-element-to-stratego =
      \[Indent(indent), Placeholder(_, sort(_){name}, _, _), Newline(_) | tail] ->
        [$[<pp-ih(|"[indent]")> [name]'] | tail]\
    <+
      // At the end, the Newline(_) may have been stripped.
      \[Indent(indent), Placeholder(_, sort(_){name}, _, _)] ->
        [$[<pp-ih(|"[indent]")> [name]']]\
    <+
      [template-element-to-stratego' | id]
    <+
      []

  template-element-to-stratego' =
      \Placeholder(_, sort(_){name}, _, _) -> $[[name]']\
    + \String(t) -> String(t)\
    + \Layout(t) -> String(t)\
    + \Indent(t) -> String(t)\
    + \Newline(t) -> String(t)\

  template-element-to-prettyprint:
    Placeholder(_, sort(x){name}, None(), _) -> $[[name]' := <prettyprint-[x]> [name]]

  template-element-to-prettyprint:
    Placeholder(_, sort(x){name}, <Star() + Plus()>, Options(opt*)) -> t
    with
      if sep := <getfirst(?Separator(<id>))> opt* then
        t := $[[name]' := <pp-list(prettyprint-[x]|"[<escape> sep]")> [name]]
      else
        t := $[[name]' := <pp-list(prettyprint-[x]|" ")> [name]]
      end

  template-element-to-prettyprint:
    Placeholder(_, sort(x){name}, Option(), _) -> $[[name]' := <pp-option(prettyprint-[x])> [name]]

  template-element-to-parenthesize(|conflicts):
    (i0, Placeholder(_, sort(x){name}, None(), _)) -> $[[name]' := <parenthesize-[x]([na])> [name]]
    where
      not(<filter(?(i0, <id>))> conflicts => conflicts' => [])
    with
      let to-match =
            {a*: \ Symbol(x, n) -> <concat-strings> ["?", x, "(", a*, ")"]
                   with a* := <range; map(!"_"); separate-by(|", ")> (0, n) \}
      in
        na := <filter(to-match); separate-by(|" + ")> conflicts'
      end

  template-element-to-parenthesize(|conflicts):
    (i0, p@ Placeholder(_, sort(x){name}, None(), _)) -> <template-element-to-prettyprint> p
    where
      <filter(?(i0, _))> conflicts => []

  template-element-to-parenthesize(|conflicts):
    (i0, p@ Placeholder(_, sort(x){name}, <not(?None())>, _)) -> <template-element-to-prettyprint> p
