module to-esv
imports
  libstratego-lib
  lib/EditorService
  include/SpoofaxLang
imports
  context/sdf/declare
  context/template/declare
  normalize/templatelang
  utils/attributes
  utils/contract
  utils/templatelang

strategies

  test-templatelang-to-esv:
    ast -> Module(modulename, NoImports(), [Completions("", listOfCompletions)])
    with
      <?CompilationUnit([], [Package(_, [Module(_, SPXModuleName(modulename), _)])])> ast;
      <?CompilationUnit([], [Package(_, [<template-module-to-esv>])]); alltd(String(double-quote))> ast => listOfCompletions

strategies

  /** @type Module -> List(Completions) */
  template-module-to-esv:
    Module(_, _, section*) -> <template-sections-to-esv> section*

  /** @type List(TemplateSection) -> List(Completions) */
  template-sections-to-esv:
    section* -> completion*
    with
      contracts(
        contract-requires(List | section*)
      )
    with
      completion* := <filter(template-section-to-esv); concat> section*
    with
      contracts(
        contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
      )

  /** @type TemplateSection -> List(CompletionTemplate) */
  template-section-to-esv:
    TemplateSection(prod*) -> completion*
    with
      contracts(
        // FIXME: remove TemplateProductionWithCons/3 when desugaring is performed before code generation.
        contract-requires(ListOf(?TemplateProduction(_, _, _) + ?TemplateProductionWithCons(_, _, _)) | prod*)
      )
    with
      // FIXME: desugaring should have been performed before the current strategy is invoked.
      completion* := <templatelang-desugar-top;
                      declare-template-definition-main;
                      filter(template-to-completion-template)> prod*
    with
      contracts(
        contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
      )

/*internal*/ strategies

  template-to-completion-template:
    TemplateProduction(sort, Template(line* @ [_ | _]), attr*) -> t
    with
      part* := <map(template-line-to-esv);
                try(\[[_, Cursor()] | tail] -> tail\); // HACK for Mobl <MetaAnno*>
                remove-cursor-except-first;
                separate-by(|String("\n"));
                flatten-list;
                concatenate-consecutive-strings;
                map(try(String(templatelang-escape)))> line*;
      // if prefix := String(<collect-one(?sdf-cons(<un-double-quote>))> attr*) then
      //   t := |[ completion template ~sort : ~prefix = ~*part* (blank) ]|
      // else
        t := |[ completion template ~sort : ~*part* (blank) ]|
      // end

  template-line-to-esv:
    Line([Layout(x), Placeholder(None(), _, <Option() + Star()>, _)]) ->
      <spaces-to-tabs> [String(x), Cursor()]

  template-line-to-esv:
    Line(elem*) -> <map(template-element-to-esv); spaces-to-tabs> elem*

  spaces-to-tabs =
    try([String(string-replace(|"  ", "\t")) | id])

  template-element-to-esv:
    Placeholder(Text(name), sort(sort), _, _) -> PlaceholderWithSort($[<[name]:], sort)

  template-element-to-esv:
    Placeholder(None(), sort(sort), <None() + Plus()>, _) ->
      PlaceholderWithSort($[<[<try(generate-placeholder)> sort]:], sort)

  template-element-to-esv:
    Placeholder(None(), sort(sort), <Option() + Star()>, _) -> []

  template-element-to-esv:
    Layout(x) -> String(x)

  template-element-to-esv:
    String(_) -> <id>

  remove-cursor-except-first =
    [[id, Cursor()] | remove-cursor] <+ [id | remove-cursor-except-first] <+ []

  remove-cursor =
    ?[[_, Cursor()] | <remove-cursor>] <+ [id | remove-cursor] <+ []

  // FIXME: Does this make sense? Answer: not any more!
  generate-placeholder =
    bagof-Declaration;
    map(\TemplateProduction(_, Template(e*), _) -> e*\);
    filter(not([])); // is this desired?
    qsort((percentage-string-elements, percentage-string-elements); gt);
    Hd;
    template-elements-to-string

  percentage-string-elements =
    ?e*;
    <divr> (<length> <filter(?String(_))> e*, <length> e*)

  template-elements-to-string =
    // trim-layout;
    filter(
         \Placeholder(Text(x), _, _, _) -> x\
      <+ \Placeholder(None(), sort(x), _, _) -> x\
      <+ \String(x) -> x\
      <+ \Layout(x) -> <string-replace(|"\t", " ")> x\
    );
    concat-strings
