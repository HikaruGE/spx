module to-esv
imports
  libstratego-lib
  lib/EditorService
  include/SpoofaxLang
imports
  context/resolve-symbols
  context/sdf/declare
  context/template/declare
  normalize/templatelang
  utils/attributes
  utils/contract
  utils/templatelang

strategies

  test-templatelang-to-esv:
    ast -> Module(modulename, NoImports(), [Completions("", listOfCompletions)])
    with
      <?CompilationUnit([], [Package(_, [Module(_, SPXModuleName(modulename), _)])])> ast;
      <?CompilationUnit([], [Package(_, [<template-module-to-esv>])]); alltd(String(double-quote))> ast => listOfCompletions

strategies

  /** @type Module -> List(Completions) */
  template-module-to-esv:
    Module(_, _, section*) -> <template-sections-to-esv> section*

  /** @type List(TemplateSection) -> List(Completions) */
  template-sections-to-esv:
    section* -> completion*
    with
      contracts(
        contract-requires(List | section*)
      )
    with
      completion* := <filter(template-section-to-esv); concat> section*
    with
      contracts(
        contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
      )

  /** @type TemplateSection -> List(CompletionTemplate) */
  template-section-to-esv:
    TemplateSection(prod*) -> completion*
    with
      contracts(
        // FIXME: remove TemplateProductionWithCons/3 when desugaring is performed before code generation.
        contract-requires(ListOf(?TemplateProduction(_, _, _) + ?TemplateProductionWithCons(_, _, _)) | prod*)
      )
    with
      // FIXME: desugaring should have been performed before the current strategy is invoked.
      // FIXME: declaring is here for unit testing only ???
      completion* := <templatelang-desugar-top;
                      declare-template-definition-main;
                      filter(template-to-completion-template)> prod*
    with
      contracts(
        contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
      )

  template-section-to-esv:
    SDFSection(lexical-syntax(prod*)) ->
      <sdf-productions-to-completion-templates> prod*

  template-section-to-esv:
    SDFSection(context-free-syntax(prod*)) ->
      <sdf-productions-to-completion-templates> prod*

  sdf-productions-to-completion-templates:
    prod* -> completion*
    with
      contracts(
        // FIXME: remove SdfProduction/3 and SdfProductionWithCons/3 when desugaring is performed before code generation.
        contract-requires(ListOf(?prod(_, _, _) + ?SdfProduction(_, _, _) + ?SdfProductionWithCons(_, _, _)) | prod*)
      )
    with
      // FIXME: desugaring should have been performed before the current strategy is invoked.
      // FIXME: declaring is here for unit testing only ???
      completion* := <templatelang-desugar-sdf-top;
                      declare-sdf-definition-main;
                      filter(sdf-production-to-template;
                             template-to-completion-template)> prod*
    with
      contracts(
        contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
      )

/*internal*/ strategies

  sdf-production-to-template:
    prod([lit(text)], sort(sort), attrs) -> 
      TemplateProduction(sort, SingleLineTemplate([String(<un-double-quote> text)]), attrs)

  template-to-completion-template:
    TemplateProduction(sort, SingleLineTemplate(elem* @ [_ | _]), attrs) ->
      |[ completion template ~sort : ~prefix = ~*part* ]|
    where
      not(<is-deprecated + is-reject> attrs)
    with {|Expanded:
      part* := <map(template-element-to-esv);
                template-to-completion-template-helper> elem*;
      prefix := <build-prefix> part*
    |}
    where
      <accept-template-parts(|sort)> part*

  template-to-completion-template:
    TemplateProduction(sort, Template(line* @ [_ | _]), attrs) ->
      |[ completion template ~sort : ~prefix = ~*part* (blank) ]|
    where
      not(<is-deprecated + is-reject> attrs)
    with {|Expanded:
      part* := <map(template-line-to-esv);
                try(\[[_, Cursor()] | tail] -> tail\); // HACK for Mobl <MetaAnno*>
                remove-cursor-except-first;
                separate-by(|String("\n"));
                template-to-completion-template-helper> line*;
      prefix := <build-prefix> part*
    |}
    where
      <accept-template-parts(|sort)> part*

  template-to-completion-template-helper =
    flatten-list;
    concatenate-consecutive-strings;
    map(try(String(templatelang-escape)))

  build-prefix =
    map(template-element-to-string);
    concat-strings;
    string-replace(|"\\n", " ");
    string-replace(|"\\t", " ");
    string-as-chars(listbu(try( \[' ', ' ' | t] -> [' ' | t]\ )));
    !String(<id>)

  accept-template-parts(|sort) =
    // not acceptable are:
    //  * empty templates
    //  * injections (i.e., a single element that isn't String(_))
    ?[_, _ | _] + ?[String(_) | _]

rules

  template-line-to-esv:
    Line([Layout(x), Placeholder(_, <Option() + Star()>, option*)]) ->
      <spaces-to-tabs> [String(x), Cursor()]
      where
        <not(one(?Placeholder(_)))> option*

  template-line-to-esv:
    line @ Line([Layout(_), Placeholder(_, <None() + Plus()>, option*)]) ->
      // ?t and not(?t) are cycle breaker
      <?t; expand-template-line; not(?t); map(template-line-to-esv)> [line]
      where
        <not(one(?Placeholder(_)))> option*

  template-line-to-esv:
    Line(elem*) -> <map(template-element-to-esv); spaces-to-tabs> elem*

  spaces-to-tabs =
    try([String(string-replace(|"  ", "\t")) | id])

  // Any placeholder with title results in a placeholder with that title.
  template-element-to-esv:
    Placeholder(sort(sort), _, option*) ->
      PlaceholderWithSort($[<[text]:], sort)
      where
        <one(?Placeholder(text))> option*

  // A and A+ result in a placeholder containing the shortest expansion of A.
  template-element-to-esv:
    placeholder @ Placeholder(sort(sort), <None() + Plus()>, option*) ->
      PlaceholderWithSort($[<[text]:], sort)
    where
      <not(one(?Placeholder(_)))> option*
    where
      text := <expand-template-element;
               map(template-element-to-string);
               concat-strings
               <+ !sort> [placeholder]

  // A? and A* result in a 0-length placeholder.
  template-element-to-esv:
    Placeholder(sort(sort), <Option() + Star()>, _) ->
      PlaceholderWithSort("<:", sort)

  template-element-to-esv:
    Layout(x) -> String(x)

  template-element-to-esv:
    String(_) -> <id>

  remove-cursor-except-first =
    [[id, Cursor()] | remove-cursor] <+ [id | remove-cursor-except-first] <+ []

  remove-cursor =
    ?[[_, Cursor()] | <remove-cursor>] <+ [id | remove-cursor] <+ []

rules // TemplateLang / completion template element to string

  template-element-to-string:
    Placeholder(_, _, option*) -> text
    where
      <one(?Placeholder(text))> option*

  template-element-to-string:
    Placeholder(sort(sort), <None() + Plus()>, option*) -> sort
    where
      <not(one(?Placeholder(_)))> option*

  template-element-to-string:
    Placeholder(_, <Option() + Star()>, option*) -> ""
    where
      <not(one(?Placeholder(_)))> option*

  template-element-to-string:
    Placeholder(t) -> t

  template-element-to-string:
    PlaceholderWithSort(t, _) -> <string-as-chars(Tl; init)> t

  template-element-to-string:
    Layout(x) -> x

  template-element-to-string:
    String(x) -> x

  template-element-to-string:
    Cursor() -> ""

strategies // Template expansion

  expand-multi-line-template-production:
    TemplateProduction(sort, SingleLineTemplate(elem*), a) ->
      <memo(expand-template-production)> TemplateProduction(sort, Template([Line(elem*)]), a)

  expand-multi-line-template-production:
    TemplateProduction(_, Template(_), _) -> <memo(expand-template-production)>

  expand-multi-line-template-production:
    prod(_, _, _) -> <memo(expand-template-production)>

  expand-single-line-template-production:
    TemplateProduction(_, SingleLineTemplate(_), _) -> <memo(expand-template-production)>

  expand-single-line-template-production:
    prod(_, _, _) -> <memo(expand-template-production)>

  expand-template-production:
    TemplateProduction(sort, template, attrs) -> result{score}
    where
    	<not(is-reject)> attrs;
      <not(Expanded)> sort
    where {|Expanded:
      rules( Expanded: sort -> sort );
      result := <expand-template> template;
      score := <determine-score> attrs
    |}

  expand-template-production:
    prod(_, _, _) -> <sdf-production-to-template; expand-template-production>

  determine-score:
    attrs -> <sum> [depr', prefer', avoid']
    where
      depr'   := <is-deprecated < !-100 + !0> attrs;
      prefer' := <is-completion-prefer < !50 + !0> attrs;
      avoid'  := <is-completion-avoid < !-50 + !0> attrs

  expand-template:
    t @ SingleLineTemplate(elem*) -> elem'*
    where
      elem'* := <listbu(expand-template-element)> elem*

  expand-template:
    t @ Template(line*) -> line'*
    where
      line'* := <listbu(expand-template-line)> line*

  is-template-placeholder:
    Placeholder(sort(x), _, _) -> <id>
    where
      <setof-Declaration; one(?TemplateProduction(_, _, _))> x

  is-template-placeholder:
    PlaceholderWithSort(_, x) -> <id>
    where
      <setof-Declaration; one(?TemplateProduction(_, _, _))> x

  // expand-template-line covers exactly all valid input terms except:
  //  Line([indent @ Layout(_), Placeholder(sort(x), <None() + Plus()>, _)]) where <Expanded> x

  expand-template-line:
    [t @ Line([indent @ Layout(_), Placeholder(sort(x), <None() + Plus()>, _)]) | tail] -> [line* | tail]
    where
      <not(Expanded)> x
    where
      line* := <get-template-lines(|indent) <+ ![t]> x

  expand-template-line:
    [t @ Line(elem*) | tail] -> [Line(elem'*) | tail]
    where
      not(!elem* => [Layout(_), Placeholder(_, <None() + Plus()>, _)])
    where
      elem'* := <listbu(expand-template-element)> elem*

  expand-template-line:
    [] -> <id>

  // expand-template-element covers exactly all valid input terms except:
  //  Placeholder(sort(x), <None() + Plus()>, _) where <Expanded> x

  expand-template-element:
    [t @ Placeholder(sort(x), <None() + Plus()>, _) | tail] -> [elem* | tail]
    where
      <not(Expanded)> x
    where
      elem* := <get-template-elements <+ ![t]> x

  expand-template-element:
    [t | tail] -> [t | tail]
    where
      not(!t => Placeholder(sort(x), <None() + Plus()>, _))

  expand-template-element:
    [] -> <id>

  // helpers

  get-template-lines(|indent) =
    setof-Declaration;
    filter(expand-multi-line-template-production);
    choose-one-expansion;
    map(Line(![indent | <id>]))

  get-template-elements =
    setof-Declaration;
    filter(expand-single-line-template-production);
    choose-one-expansion

  choose-one-expansion =
       filter(not(oncetd(is-template-placeholder)));
       qsort(template-compare);
       Hd
    <+
       Hd

  // prefer least amount of literal characters
  template-compare:
    (x{x-score}, y{y-score}) -> <id>
    where
      <gti> (x-score, y-score)
    <+
      <eq> (x-score, y-score);
      <lti> (<template-character-count> x, <template-character-count> y)

  template-character-count =
    ?String(<string-length>)
    <+ ?Layout(<string-length>)
    <+ ?Placeholder(<string-length>)
    <+ crush(!0, addi, template-character-count)

  lti = not(gti)

  setof-Declaration =
    to-package-scoped-symbol;
    bagof-Declaration; nub; is-not-empty

  is-not-empty = ?[_ | _]
