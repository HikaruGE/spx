module to-sdf
imports
  libstratego-lib
  libstratego-sglr
  include/SpoofaxLang
imports
  common
  context/template/declare
  normalize/templatelang
  utils/annotations
  utils/contract
  utils/debug
  utils/tokenize
  utils/templatelang

strategies

  test-templatelang-to-sdf:
    ast -> 'module(unparameterized(modulename), [], [exports(grammars)])
    with
      init-template-options;
      <?CompilationUnit([], [Package(_, [Module(_, SPXModuleName(modulename), sections)])])> ast;
      (options, t-sections) := <partition(?TemplateOptions(<id>))> sections;
      <try([declare-template-options-main])> options;
      <template-sections-to-sdf /*;alltd(quoted(double-quote))*/> t-sections;
      (\[x] -> x\ + \[x, y] -> conc-grammars(x, y)\) => grammars

strategies

  /** @type List(TemplateSection) -> List(grammar) */
  template-sections-to-sdf:
    section* -> sdf-section'*
    with
      contracts(
        contract-requires(ListOf(?TemplateSection(_)) | section*)
      )
    with
      // FIXME: desugaring should have been performed before the current strategy is invoked.
      sdf-section*  := <templatelang-desugar-top; map(template-section-to-sdf)> section*;
      sdf-section'* := <add-contentcomplete; add-lexical-restrictions> sdf-section*
    with
      contracts(
        contract-requires(ListOf(?context-free-syntax(_) + ?lexical-restrictions(_)) | sdf-section'*)
      )

/*internal*/ strategies

  /** @type TemplateSection -> grammar */
  template-section-to-sdf:
    TemplateSection(prod*) -> G|[
      context-free syntax
        p*
    ]|
    with
      // main productions
      // FIXME: declaring should have been performed before the current strategy is invoked.
      p* := <declare-template-definition-main; map(template-production-to-sdf)> prod*

  /** @type List(grammar) -> List(grammar) */
  add-contentcomplete:
    sdf-section* -> [sdf-section*, injections*]
    with
      A* := <collect-om(?sort(_)); nub; string-sort-ex> sdf-section*;
      p* := <map(sort-to-contentcomplete)> A*;
      if !p* => [] then
        injections* := []
      else
        injections* := [context-free-syntax(p*)]
      end

  /** @type List(grammar) -> List(grammar) */
  add-lexical-restrictions:
    sdf-section* -> [sdf-section*, restrictions*]
    with
      let ends-with-identifier-char =
            where(
              explode-string;
              un-double-quote-chars;
              // Must end with idenfifier character, may not be preceded by backslash.
              reverse; ?[<is-alphanum + '_' + '-'> | <not(?['\' | _])>]
            )
      in
        A* := <collect-om(lit(ends-with-identifier-char)); nub; string-sort-ex> sdf-section*;
        r  := <Options> KeywordFollowRestriction();
        if (!A* => []) + (!r => None()) then
          restrictions* := []
        else
          restrictions* := [lexical-restrictions([follow(A*, r)])]
        end
      end

  // Used when rewriting `Sort.Cons' in priority sections to a production.
  template-production-to-sdf-no-attrs:
    TemplateProduction(S', t, _) -> p|[ A* -> S' ]|
    with
      A* := <template-to-sdf> t

  template-production-to-sdf:
    TemplateProduction(S', t, attrs') -> p|[ A* -> S' attrs' ]|
    with
      A* := <template-to-sdf> t

  template-to-sdf:
    SingleLineTemplate(elem*) -> A*
    with
      A* := <filter(template-element-to-sdf);
             flatten-list> elem*

  template-to-sdf:
    Template(line*) -> A*
    with
      A* := <filter(?Line([Layout(_), _ | _]));
             map(template-line-to-sdf);
             flatten-list> line*

  template-line-to-sdf =
    ?Line(<id>);
    if not(?[Layout(_), Placeholder(_, _, _, _)]) then
      switch <Options> Newlines()
        case ?None()     : id
        case ?Leading()  : ![String("\n") | <id>]
        case ?Trailing() : (elem* -> [elem*, String("\n")])
      end
    end;
    filter(template-element-to-sdf)

  template-element-to-sdf:
    String(x) -> <string-to-sdf> x

  template-element-to-sdf:
    Placeholder(_, sort(S), None(), _) -> A|[ S ]|

  template-element-to-sdf:
    Placeholder(_, sort(S), Option(), _) -> A|[ S? ]|

  template-element-to-sdf:
    Placeholder(_, sort(S), Star(), Options(option*)) -> A|[ S* ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf:
    Placeholder(_, sort(S), Star(), Options(option*)) -> A|[ { S L }* ]|
    where <one(Separator(not(string-is-layout)))> option*
    with L := <separator-to-literal> option*

  template-element-to-sdf:
    Placeholder(_, sort(S), Plus(), Options(option*)) -> A|[ S+ ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf:
    Placeholder(_, sort(S), Plus(), Options(option*)) -> A|[ { S L }+ ]|
    where <one(Separator(not(string-is-layout)))> option*
    with L := <separator-to-literal> option*

  char-is-layout =
    ' ' + '\t' + '\r' + '\n'

  string-is-layout =
    string-as-chars(all(char-is-layout))

  remove-layout =
    string-as-chars(filter(not(char-is-layout)))

  separator-to-literal =
    getfirst(?Separator(<remove-layout; templatelang-escape; double-quote>))

  sort-to-contentcomplete:
    sort(S) -> p|[ CONTENTCOMPLETE -> S {cons(L)} ]|
    where
      L := $["COMPLETION-[S]"]

strategies

  /**
   * Sorts a list of terms on the outermost string within each term.
   */
  string-sort-ex =
    qsort(<string-lt> (<collect-one(is-string)>, <collect-one(is-string)>))

  /**
   * Split on the edges delimiting identifiers.
   * E.g. "func(x,y)" => ["func", "(", "x", ",", "y", ")"]
   */
  string-to-sdf =
    // FIXME: Use identifier lexical (or keyword follow restriction?) defined by the language.
    string-edge-tokenize(is-alphanum + '_');
    // FIXME: Case insensitive literals need ci-lit/single-quote.
    map({raw, sdf:
      ?raw; !lit(<templatelang-escape; double-quote>); ?sdf;
      if <explode-string; at-last(is-alphanum + '_')> raw then
        rules(Restrictions :+= sdf)
      end
    })
