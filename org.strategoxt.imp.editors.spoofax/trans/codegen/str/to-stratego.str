module codegen/str/to-stratego
imports
	libstrc
imports
  libstratego-lib
	lib/editor-common.generated
imports
  include/SpoofaxLang
imports
	common
	config
	utils/debug
	utils/path
	utils/annotations
imports
	codegen/compile
  codegen/generate
	codegen/main
	codegen/sdf/to-name-analysis
  codegen/sdf/to-signature
imports
	context/-
imports
	normalize/signatures
	utils/contract
	common
imports
  templatelang/to-str


rules
	// emit STR definition for the specified SPX module.
 	emit-str:
		m@Module(attrb* , modname , section*) -> m
		where
			with-spxverify(
	 			 project-path := <ProjectPath>
	 			 ; root-dir := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
	 			 ; package-typed-qname := <GetEnclosingPackageName>
				 ; module-typed-qname  := <GetEnclosingModuleName>
				 , !$[ Codegen | STR | Failed to create current scope.]
			)	  
		where
	 		!module-typed-qname  => Module(module-untyped-qname)
			; !package-typed-qname => Package(package-untyped-qname)
		 	; !modname             => SPXModuleName(modulename-string)
		 	; dbg-compiler(!$[CodeGen | STR | generating code for the following module : [<print-as-string>module-untyped-qname]])
		where
			emit-str-rtree(| package-untyped-qname, module-untyped-qname, root-dir)
			; emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname, root-dir)
	 	  ; dbg-compiler(!$[ Codegen | STR | Finishing generation of following module: [<print-as-string> module-untyped-qname].])


	// emit stratego concrete syntax
	emit-str-concrte-syntax(| package-untyped-qname, module-untyped-qname , root-dir) :
		str-rtree -> str-concrete-syntax
		where
			output-path-str 	    := <get-output-path(|"str")>(root-dir, module-untyped-qname)
   		; str-concrete-syntax := <to-str-string>str-rtree
			; <save-artifact(|package-untyped-qname, root-dir,output-path-str)> str-concrete-syntax

	// emit stratego rtree
	emit-str-rtree (|package-untyped-qname, module-untyped-qname , root-dir):
		Module(attrb* , modname , section*) -> str-aterm
		where
			with-spxverify(
				output-path-rtree    := <get-output-path(|"rtree")>(root-dir, module-untyped-qname)
				; ! " failed to get output-path-rtree @emit-str-rtree"
			)
			; str-section-def := <conc>(<collect-om(?STRSection(<id>), conc)> section* ,<get-name-analysis>section*)
			; str-aterm := Module(
			 										 <qname-to-path>module-untyped-qname,
			 										 <conc>(<to-str-imports-block(|module-untyped-qname)>section*,
			 											  		str-section-def
			 													 )
			 										)
			; <save-artifact(WriteToBinaryFile | package-untyped-qname, root-dir,output-path-rtree)> str-aterm

rules
	// Generates main stratego module for the specified package-name
	generate-str-main:  
		module-qname* -> <id>
		where
			with-spxverify(
			 project-path             := <ProjectPath>
 			 ; Package(package-qname)   := <GetEnclosingPackageName>
 			 ; root-directory 					:= $[[project-path]/[<get-autogenerated-artifacts-dir>]]
 		  )
 		  ; dbg-compiler(!$[CodeGen | STR | Generate-str-main from package-name: [<print-as-string>package-qname]])
 		  ; with-spxverify(
	 			 main-str-module-name :=  <get-main-file-name><GetEnclosingPackageName>
	       ; pp-module-name := <conc-strings>(main-str-module-name, "-prettyprinter")
				 ; str-aterm := Module(main-str-module-name, [
				   	Imports(<get-str-imports(|<GetEnclosingPackageName>)>module-qname*),
				    Imports([Import(pp-module-name)])
		 		   ]
			     )
	 			 ; str-string := <pp-stratego-string> <parenthesize-Stratego>  str-aterm
		    )
		  ; with-spxverify(
			 		  <save-artifact(save-to-file      | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "str")>(root-directory, package-qname))>str-string
					; <save-artifact(WriteToBinaryFile | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "rtree")>(root-directory, package-qname))>str-aterm
		  	)
			; dbg-compiler(!$[ Codegen | STR | Generation of Main STR Module for package : [<print-as-string> package-qname] is done])
			// Generating pretty-printer if templatelang is enabled 
			; if templatelang-enabled then    
					 with-spxverify(
				    	dbg-compiler(!$[Codegen | STR | Generating prettyprinter from package-name: [<print-as-string> package-qname]]);
				    	//TVO-FIXME: {|SubtermConflicts:
					    //TVO-FIXME:  <sdf2conflicts> []
					      // HACK: this lacks any sanity wrt the original modules in which the SDF was placed ...
					        section* := <map(get-original-module-definition; ?Module(_, _, <id>)); concat> module-qname*
				        ; section'* := <filter(?SDFSection(_) + ?SDFSectionEH(_, _) + ?TemplateSection(_))> section*
				        ; activate-internal-scope(  
				        	// this uses information collected by sdf2conflicts
				        	pp-aterm := <template-sections-to-stratego> section'*
				        )  
				   	 //TVO-FIXME:|}
			       ; pp-string := <pp-stratego-string> <parenthesize-Stratego> pp-aterm
				     ; pp-qname := <QName(at-last([<conc-strings>(<id>, "-prettyprinter")]))> package-qname
				     ; <save-artifact(save-to-file      | pp-qname , root-directory, <get-main-output-path(|pp-module-name, "str")>(root-directory, pp-qname))> pp-string
				     ; <save-artifact(WriteToBinaryFile | pp-qname , root-directory, <get-main-output-path(|pp-module-name, "rtree")>(root-directory, pp-qname))> pp-aterm
					   ; dbg-compiler(!$[ Codegen | STR | Generation of prettyprinter : [<print-as-string>package-qname] is done.])
						)
				end
rules

	// get name analysis for  the specified sections
	get-name-analysis :  
		sections* -> result
		where
			sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
			Module(_, result) := <generate-name-analysis>sdf-section*
		<+
			dbg-compiler(!$[ Codegen | STR | Failed name analysis.])



rules

	to-str-string: 
		sections* -> str-section-block
		where
			str-section-block := <parenthesize-Stratego; pp-stratego-string>sections*

	to-str-imports-block(|module-qname): 
		sections*  ->str-import-block
		where
			with-spxverify(
				verify( is-list |sections* , "expected List")
				; verify( ?QName(_)|module-qname , "expected:QName(_)")
				, !"to-str-imports-block failed in contracts validations" 
			)
			; spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
			if <ensure-list-is-not-empty>spx-import-stmt*  then
				str-import-block' := <to-generated-artifact-block(to-generated-artifacts-import-declarations(to-str-import), \s -> [Imports(s)]\)>spx-import-stmt*
			else
				str-import-block' := []
			end;
			module-qualified-path := <qname-to-path>module-qname ;
			str-import-block := <flatten-list>[[Imports([Import(<get-signature-file-name>module-qualified-path)])], str-import-block']


rules

	// Returns the import statements for this package.
	// In addition, it imports Internal Signatures for this package
	// And by default add reference to libstratego-lib
	get-str-imports(|package-qname): 
		module-qnames* -> result
		where
			result' := <map(to-str-import);flatten-list>module-qnames*
		where
			<to-str-import><get_internal_module_qtname>package-qname => [_, sig-import];
			result := <conc>([Import("libstratego-lib"),sig-import] , result')

rules

	to-str-import:
		package-name -> [Import(package-name) , Import(<get-signature-file-name>package-name)]
		where
			<is-string>package-name

	to-str-import:
		legacy-artifact@Name(name)  -> 	result
 		where
			if(
				<is-declared-legacy-artifact> name
			<+
				<has-extension(|"str")+	has-extension(|"rtree")><get-enclosed-legacy-artifact-details>
			)
			then
				// Importing legacy artifact. Please note that , for legacy artifact, signatrue is not included
				// as it is taken care of during signature generation of _Internal module for every package.
				result :=  [Import(name)]
			else
				result :=  []
			end

	to-str-import:
		Module(q@QName(qnameparts*))->[Import(str-import),Import(sig-import)]
		where
			str-import:= <qname-to-path>q;
			sig-import:= <get-signature-file-name>str-import
