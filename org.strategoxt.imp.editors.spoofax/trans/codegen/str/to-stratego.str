module codegen/str/to-stratego
imports 
	libstrc
imports
  libstratego-lib
	lib/editor-common.generated
imports
  include/SpoofaxLang
imports 
	common
	config
	utils/debug	
	utils/path
	utils/annotations	
imports 	
	codegen/sdf/to-signature
	codegen/compile
	codegen/main
	codegen/generate
	codegen/sdf/to-name-analysis
imports	
	context/-
imports	
	normalize/signatures
	utils/contract

	
	
rules
	// emit STR definition for the specified SPX module.
 	emit-str:
		m@Module(attrb* , modname , section*) -> m
		with 
 			 project-path := <ProjectPath>
 			;root-dir := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
 		with
 			package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			<debug-compiler>$[ Codegen | STR | Failed to create current scope.] 
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			;!modname             => SPXModuleName(modulename-string)
			;<debug-compiler> $[CodeGen | STR | generating code for the following module : [<pp-aterm>module-untyped-qname]] 
		where 
			emit-str-rtree(| package-untyped-qname, module-untyped-qname, root-dir);
			emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname, root-dir)
	 	 ;<debug-compiler>$[ Codegen | STR | Finishing generation of following module: [<pp-aterm> module-untyped-qname].]

	
	// emit stratego concrete syntax
	emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname , root-dir) : 
		str-rtree -> str-concrete-syntax
		with 
			output-path-str 	    := <get-output-path(|"str")>(root-dir, module-untyped-qname)
   	where
			 str-concrete-syntax := <to-str-string>str-rtree
			;<save-artifact(|package-untyped-qname, root-dir,output-path-str)> str-concrete-syntax
	
	// emit stratego rtree 
	emit-str-rtree (|package-untyped-qname, module-untyped-qname , root-dir): 
		Module(attrb* , modname , section*) -> str-aterm
		with
			output-path-rtree    := <get-output-path(|"rtree")>(root-dir, module-untyped-qname)
		where  
			 str-section-def := <conc>(<collect-om(?STRSection(<id>), conc)> section* ,<get-name-analysis>section*)     
			;str-aterm := Module(
			 										 <qname-to-path>module-untyped-qname, 
			 										 <conc>(<to-str-imports-block(|module-untyped-qname)>section*, 
			 											  		str-section-def
			 													 )
			 										)
			;<save-artifact(WriteToBinaryFile | package-untyped-qname, root-dir,output-path-rtree)> str-aterm 

	// Generates main stratego module for the specified package-name
	generate-str-main:  module-qname* -> <id>
		with 
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>;
 			 root-directory 					:= $[[project-path]/[<Autogenerated-Artifacts-Dir>]]; 
 		   <debug-compiler> $[CodeGen | STR | Generate-str-main from package-name: [<pp-aterm>package-qname]]
 		where   	  
 			 main-str-module-name :=  <get-main-file-name>(); 
			 str-aterm := Module( main-str-module-name  ,[Imports(<get-str-imports(|<GetEnclosingPackageName>)>module-qname*)]);
			 str-string := <pp-stratego-string> <parenthesize-Stratego>  str-aterm
		where
			<save-artifact(save-to-file      | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "str")>(root-directory, package-qname))>str-string;
			<save-artifact(WriteToBinaryFile | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "rtree")>(root-directory, package-qname))>str-aterm;
			<debug-compiler>$[ Codegen | STR | Generation of Main STR Module for package : [<pp-aterm> package-qname] is done.] 

	 			
				
rules
	
	// get name analysis for  the specified sections
	get-name-analysis : sections* -> result 
	where 
		sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
		Module(_, result) := <generate-name-analysis>sdf-section*
	<+
		<debug-compiler>$[ Codegen | STR | Failed name analysis.]
	
	

rules
	
	to-str-string: sections* -> str-section-block  
	where 
		str-section-block := <parenthesize-Stratego; pp-stratego-string>sections*

	to-str-imports-block(|module-qname): sections*  ->str-import-block 
	with 
		contracts( 
			contract-requires ( is-list |sections*);
			contract-requires ( ?QName(_)|module-qname)
		)
	where 
		spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
		if <ensure-list-is-not-empty>spx-import-stmt*  then
			str-import-block' := <to-generated-artifact-block(to-generated-artifacts-import-declarations(to-str-import), \s -> [Imports(s)]\)>spx-import-stmt*
		else
			str-import-block' := []
		end;
		module-qualified-path := <qname-to-path>module-qname ;
		str-import-block := <flatten-list>[[Imports([Import(<get-signature-file-name>module-qualified-path)])], str-import-block'] 


rules						 
	
	// Returns the import statements for this package. 
	// In addition, it imports Internal Signatures for this package
	// And by default add reference to libstratego-lib
	get-str-imports(|package-qname): module-qnames* -> result 
	where
		result' := <map(to-str-import);flatten-list>module-qnames*    
	where
		<to-str-import><get_internal_module_qtname>package-qname => [_, sig-import];
		result := <conc>([Import("libstratego-lib"),sig-import] , result')
	
rules
				
	to-str-import: 
		package-name -> [Import(package-name) , Import(<get-signature-file-name>package-name)]
		where 
			<is-string>package-name
			
	to-str-import: 
		legacy-artifact@Name(name)  -> 	result 
 	where
 			if(<UsedLegacyArtifacts>(Globals() , name) => Unresolved()) then
 				result := [Import(name)]  // Probably lib legacy imports . SInce, it is unresolved, no signature is generated for this import
 			else 
 				result :=  [Import(name) , Import(<get-signature-file-name>name)] 
			end	
 		
	to-str-import: 
		Module(q@QName(qnameparts*))->[Import(str-import),Import(sig-import)]
		where 
			str-import:= <qname-to-path>q;
			sig-import:= <get-signature-file-name>str-import
