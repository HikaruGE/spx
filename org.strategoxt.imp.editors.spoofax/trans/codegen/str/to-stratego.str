module codegen/str/to-stratego
imports 
	libstrc
imports
  libstratego-lib
	lib/editor-common.generated
imports
  include/SpoofaxLang

imports 
	common
	config
	utils/debug
	codegen/sdf/to-signature
	codegen/compile
	utils/path
	codegen/main
	context/signature
	normalize/signatures
	utils/annotations
	context/scope-tree
	
	
rules

 	to-str-all = id
 	
 	/** 
	* Generates stratego output for the specified package-name, module-name and related definition
	* 
	* @param project-path : path to the to project root folder 
	*/	
	emit-str:
		m@Module(attrb* , modname , section*) -> m
		with 
 			project-path := <ProjectPath>
 		with
 			package-typed-qname := <GetEnclosingPackageName> 
			;module-typed-qname  := <GetEnclosingModuleName> 
			<+ 
			debug(!"CodeGeneration | STR | Failed to create current scope.")
			;fail
		where
			 !module-typed-qname  => Module(module-untyped-qname)
			;!package-typed-qname => Package(package-untyped-qname)
			;!modname => SPXModuleName(modulename-string)
		where
			Module(_, _ , section') := <get-module-declaration>module-typed-qname 
			;import-stmt* := <make-set><collect-om(?Imports(<id>) , conc);flatten-list> section'
			;debug(!"2 : Imports : ")
			;sections'*  := <collect-om(?STRSection(<id>), conc)> section*
		where
			debug(!"3 :");
			import-temp* := <str-import-declarations>import-stmt*;
			str-import-stmt* := [Imports(import-temp*)];
			str-section := <conc>(str-import-stmt* , sections'*);
			str-aterm := Module(<qname-to-path>module-untyped-qname, str-section);
 			str-string := <pp-stratego-string> <parenthesize-Stratego> str-aterm	
		where
			debug(!"6 :");
			autogen-dir := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;output-path-str := <get-output-path(|"str")>(autogen-dir, module-untyped-qname)
    	;output-path-rtree := <get-output-path(|"rtree")>(autogen-dir, module-untyped-qname)
    	;<ensure-exists>( autogen-dir , package-untyped-qname ) 
			;chdir-to-project-path 
			;<save-to-file>( output-path-str, str-string )
			;<WriteToBinaryFile>( output-path-rtree, str-aterm)
			;<refresh-workspace-file>output-path-str
			;<refresh-workspace-file>output-path-rtree
			
  
	
	/** 
	* Generates stratego MAIN output for the specified package-name
	* 
	* @param project-path : path to the to project root folder
	* @param : package name 
	* @param : relative output path from the  configured autogenerated directory  
	*/	
	generate-str-main:  module-qname* -> <id>
		with 
 			 project-path             := <ProjectPath>;
 			 Package(package-qname)   := <GetEnclosingPackageName>
 		where debug(!"generate-str-main 1 :")
 		with	 
 			 relative-autogen-path :=  <qname-to-path>package-qname
 			;autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
 		where debug(!"2 :")	  
 		where
 			main-str-module-name := <concat-strings>[relative-autogen-path, "/", <get-main-file-name>package-qname] ;
			str-aterm := Module( main-str-module-name  ,[Imports(<map(to-str-import);flatten-list>module-qname*)])
			;str-string := <pp-stratego-string> <parenthesize-Stratego>  str-aterm
		where 
			debug(!"3 :")   
		where
			autogen-root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
			;<ensure-exists>(autogen-root-directory , package-qname)
			;chdir-to-project-path // making sure that the current path is the project - path 
			;output-path-str   := <get-main-output-path(|"str")>(autogen-root-directory , package-qname)   
			;output-path-rtree := <get-main-output-path(|"rtree")>(autogen-root-directory , package-qname)   
			;<save-to-file>(output-path-str ,   str-string)		// saving str string 		
			;<WriteToBinaryFile>(output-path-rtree , str-aterm ) // saving rtree 
	 		;<refresh-workspace-file>output-path-str
			;<refresh-workspace-file>output-path-rtree
			
	to-str-import: 
		package-name-> [Import(package-name) , Import(<get-signature-file-name>package-name)]
	
	to-str-import: 
		Module(q@QName(qnameparts*))->[Import(str-import),Import(sig-import)]
		where 
			str-import:= <qname-to-path>q;
			sig-import:= <get-signature-file-name>str-import
		
rules			
	//TODO : remove code duplications 
	str-import-declarations=
		debug(!"test 0: "); 
		?imports*;
		debug(!"test 1: ");
		map(debug;str-import-declaration;debug);
		debug(!"RESULT' STR: ");
		flatten-list;
		make-set;
		debug(!"RESULT STR: ") 
		
	str-import-declaration: 
		i@ImportPackage(package-qname) -> results
		where 
			debug(!"import package : ") 
			where 
			if not(<DeclaredPackage>package-qname) then
				debug(!"import package :  found NA");
				results := [] // unresolved imports. ignore. 
			else
				<get-enclosed-modules>Package(package-qname) => modules*
				;debug(!"converting to module paths : ")
				;<map(?Module(<id>) ; qname-to-path ; to-str-import)> modules* => results
				;debug(!"results : ") 
			end
	
	str-import-declaration: 
		i@ImportSpxModule(QName(package-qname-parts), SPXModuleName(modname)) -> result
		where 
			debug(!"import module : ") 
		where
			 module-qname 			 := <get-module-untyped-qname> (package-qname-parts , modname)
			;if(not(<DeclaredModule>module-qname))  then
					result := [] // unresolved imports. ignore. 
			else
				module-name-path    := <qname-to-path>module-qname
				;<to-str-import>module-name-path => result'
				;result := [result']  
			end 
	
	str-import-declaration: i@ImportPackage(Name(package-name)) -> result
	where 
		debug(!"import name : ")
	where
			if <DeclaredPackage>QName([package-name]) then
				<get-enclosed-modules>Package(QName([package-name])) => modules*
				;debug(!"converting to module paths : ")
				;<map(?Module(<id>) ; qname-to-path ; to-str-import)> modules* => result
				;debug(!"results : ")
			else
				<to-str-import>package-name => result'
				;result := [result']	
			end
		

	str-import-declaration: 
		i@ImportLegacyArtifact(Name(modulename)) -> result
	where debug(!"legacy  : ")
		where 
			if not(<get-annotation(get-unresolved-symbol-annotation)>i) then 
				![] => result
			else
				<to-str-import>modulename => result'
				;result := [result']	
			end	