module context/scope-tree
imports
	include/SpoofaxLang 
imports 
	context/signatures 
	context/resolve-symbols
	normalize/signatures
imports 	
	common
	utils/debug 

	
//TODO OPTIMIZE : eliminate redundant dynamic rules. Declared with package definition most likely is a redundant DR

rules 

	// Scope Tree implementation using Dynamic Rules
	store-package-abspath: 
		(package-untyped-qname , abspath) -> <id>
		with 
			rules( 
				DeclaredPackage   :+ package-untyped-qname -> abspath
				PackagesDeclaredIn:+ abspath -> package-untyped-qname 
			)
		where 
			<debug-symboltable>$[ScopeTree|storing abs path | DeclaredPackage: [<pp-aterm>package-untyped-qname]-> [<pp-aterm>abspath]]
	
	store-module-abspath: 
		(module-untyped-qname, abspath) -> <id>
		with 
			rules(
				DeclaredModule:+ module-untyped-qname -> abspath
			)
		where 
			<debug-symboltable>$[ScopeTree|storing abs path| DeclaredModule: [<pp-aterm>module-untyped-qname]-> [<pp-aterm>abspath]]
	
	store-declaration(|ScopedSymbol): ( untyped-qname , definition) -> <id>
		with 
			rules( Declared : (ScopedSymbol, untyped-qname ) -> definition) 
		where	
			<debug-symboltable>$[ScopeTree|storing declaration| Declared: [<pp-aterm>untyped-qname]-> [<pp-aterm>definition]] 
	
	store-original-declaration(|ScopedSymbol): ( untyped-qname , definition) -> <id>
		with 
			rules( DeclaredOriginal : (ScopedSymbol, untyped-qname ) -> definition) 
		where	
			<debug-symboltable>$[ScopeTree|storing declaration| Declared: [<pp-aterm>untyped-qname]-> [<pp-aterm>definition]] 
	
	
	store-scope-reference: (typed-qname, typed-qname-ofparent) -> <id>
		with 
			rules( 
				GetEnclosingScope :+  typed-qname 				 -> typed-qname-ofparent
				GetEnclosedScope  :+  typed-qname-ofparent -> typed-qname 
			)				
		where	
			<debug-symboltable>$[ScopeTree|storing enclosing namespace reference| GetEnclosingNamespace: [<pp-aterm>typed-qname]-> [<pp-aterm>typed-qname-ofparent]]
	
	
	store-declaration(|Type): 
		x -> x
		where
			scoped-x := <to-scoped-symbol>x;
			rules( Declaration : (Type, scoped-x) -> x)
		where
			<debug-symboltable>$[ScopeTree|Storing Declaration [<pp-aterm>(Type, scoped-x)] -> [<pp-aterm>x]]	
	
	// Stores langauge name. It keeps mapping of package name and its defined language-names
	// extended dynamic rules are used to verify that language name is not declare multple times 
	// in a package scope. Additional checks will be added to verify a language-name is unique 
	// in a project scope. 
	store-langauge-properties (| package-typed-qname ) : 
		LanguageName(name) -> <id>
		with 
			rules( DeclaredLangaugeName :+ package-typed-qname -> name);
			rules( DeclaredLangaugeNameInScope :+ name -> package-typed-qname )
		where
			<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following language name : [<pp-aterm>name]]
	
	// Stores Language ID. 
	store-langauge-properties (| package-typed-qname ) : 
		LanguageId(id-string) -> <id> 
		with 
			rules( DeclaredLangaugeId :+ package-typed-qname -> id-string)
			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following language Id : [<pp-aterm>id-string]]
	 
	store-context-free-start-symbols(|package-typed-qname) : 
	 	context-free-start-symbols(sorts*) -> <id>
	 	with 
			rules( DeclaredContextFreeStartSymbols :+ package-typed-qname -> sorts*)
			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following start symbols : [<pp-aterm>sorts*]]
	 		 		