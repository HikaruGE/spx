module context/str/declare

imports
	libstrc		
	libstratego-lib
 	libstratego-gpp
	libstratego-aterm
imports
	lib/editor-common.generated
	include/SpoofaxLang
imports  	
 	normalize/stratego
imports	
	utils/sourcedir
 	utils/debug
 	common
	config 
imports 
	context/str/signature-generator
	context/scope-tree   
 

rules 
	
	getStrDeclaration = 
 		?cookie; 
 		<resolve-symbol-unique-declaration(all-keys-STRDeclaration, bagof-STRDeclaration)><to-scoped-symbol>cookie 
 	<+
 		<debug-declaration> $[DeclareSTR | Failed to retrive STRDeclaration for cookie [<pp-aterm-forced><to-scoped-symbol>]];
 		fail
	
	getCookie =
			?sig; 
 			<resolve-symbol-unique-declaration(all-keys-DeclareCookie, bagof-DeclareCookie)><to-scoped-symbol>sig
 		<+
 			<debug-declaration> $[DeclareSTR | Failed to retrive DeclareCookie for signature [<pp-aterm>]];
 			fail
	 
rules 
	is-constructor =
    (?(_, _); getCookie; getStrDeclaration <+ declaration-of);
    (?OpDecl(_, _) + ?ExtOpDecl(_, _))

  is-congruence-signature:
    (x, s, 0) -> (x, s, [])
    where
      <getCookie> (x, s)   
 
  declare-cookie-of =
    signature-of; getCookie

  declaration-of =
    signature-of; (?_{<getStrDeclaration>} <+ ?(_{<getStrDeclaration>}, _) <+ ?(_{<getStrDeclaration>}, _, _))

rules 
  
  declare-definition:
    def -> cookie
    with
      sig := <signature-of>
      ;if not(<getCookie> sig) then
         cookie := <newterm>
        ;scoped-cookie :=<to-scoped-symbol> cookie
        ;scoped-sig    :=<to-scoped-symbol> sig
        ;rules(
          DeclareCookie:  scoped-sig  -> cookie
          STRDeclaration: scoped-cookie  -> def
        )
      else
       	cookie := <getCookie> sig 
      end

  redeclare-definition:
    def -> cookie
    with
    	sig := <signature-of>
      ;cookie := <newterm>
      ;scoped-cookie :=<to-scoped-symbol> cookie
      ;scoped-sig    :=<to-scoped-symbol> sig
      ;rules(
        DeclareCookie:  scoped-sig    -> cookie
        STRDeclaration: scoped-cookie -> def
      )
  external SRTS-EXT-newint(|)
  
rules 
	
	declare-str-definition-main =  
		declare-stratego-globals-top;
		declare-bodies-top
	
	declare-stratego-globals-top =
    if not(NoAnalysis) then
    	where(<debug-declaration>$[DeclareSTR | Inside stratego-globals-top : [<pp-aterm>]]);
    	//TODO : FIX handle it during legacy-compilation
    	//with(<declare-str-globals>Import("libstratego-lib")); 
      alltd(declare-str-definition)
    end

  declare-str-definition:
    SDefT(x, s*, t*, s) -> SDefT(x', s*, t*, s')
    with
    	x' := x{<declare-definition>};
      s' := <topdown(try(declare-dynrule))> s
	
	declare-str-definition:
    OpDecl(x, t) -> OpDecl(x', t)
    with
      cookie := <redeclare-definition>;
      x'     := x{cookie}
    with
      // Declare congruence
      (x'', n) := <signature-of>;
      sig'     := (x'', n, 0);
      scoped-sig'  :=<to-scoped-symbol> sig';
      rules(
        DeclareCookie: scoped-sig' -> cookie
      )
  
   declare-str-definition:
    ExtSDef(x, s*, t*) -> <id>
    with
      redeclare-definition
	
  declare-str-definition:
    ExtOpDecl(x, t) -> <id>
    with
     redeclare-definition
	
  declare-str-definition:
    Overlay(x, t, d) -> Overlay(x', t, d)
    with
      cookie := <redeclare-definition>;
      x'     := x{cookie}
    with
      // Declare congruence
      (x'', n)     := <signature-of>;
      sig'         := (x'', n, 0);
      scoped-sig'  :=<to-scoped-symbol> sig';
      rules(
        DeclareCookie: scoped-sig'   -> cookie
      )
  declare-dynrule:
    dec @ RDecT(x, s*, t*) -> RDecT(x', s*, t*)
    where
      not(!x => COMPLETION(_))
    with
      x' := x{<declare-cookie-of>}
    <+
      cookie := <newterm>;
      x'  := x{cookie};
      s'* := <length> s*;
      t'* := <length> t*;
      sig := (x, s'*, t'*);
      scoped-cookie :=<to-scoped-symbol> cookie;
      scoped-sig    :=<to-scoped-symbol> sig;
      scoped-x      :=<to-scoped-symbol> sig;
      rules(
        DeclareCookie:  scoped-sig    -> cookie
        DeclareCookie:  scoped-x      -> cookie
        STRDeclaration: scoped-cookie -> dec
      );
      // See https://svn.strategoxt.org/repos/StrategoXT/strategoxt/trunk/strc-core/lib/stratego/strc/front/lift-dynamic-rules.str
      ![ "new", "undefine", "aux", "once", "bagof", "reverse-bagof", "bigbagof", "all-keys"
       , "innermost-scope", "break", "break-to-label", "break-bp", "continue", "continue-to-label"
       , "throw", "chain", "bigchain", "fold", "bigfold" ];
      list-loop({prefix, sig, cookie':
        ?prefix;
        sig := ($[[prefix]-[x]], s'*, t'*);
        scoped-sig' := <to-scoped-symbol> sig;
        rules(DeclareCookie: scoped-sig'  -> cookie)
      })

  dr-scope-declare-cookies(defs, s):
    t -> t'
    with
      defs        := <defs>;
      old-cookies := <map(!(<signature-of>, <declare-cookie-of <+ !()>))>;
      t'          := <s> t;
      <list-loop({
        ?(sig, cookie);
        if !cookie => () then
        	scoped-sig    :=<to-scoped-symbol> sig;
          rules(DeclareCookie :- scoped-sig)
        else
        	scoped-sig    :=<to-scoped-symbol> sig;
          rules(DeclareCookie : scoped-sig -> cookie)
        end
       })> old-cookies

rules // Declarations inside definition bodies

  declare-bodies-top =
    alltd(propose-completion <+ declare-bodies)

  declare-bodies:
    SDefT(x, s*, t*, s) -> SDefT(x, s'*, t'*, s')
    with
      {| DeclareCookie:
        s'* := <map(declare-svar)> s*;
        t'* := <map(declare-tvar)> t*;
        s'  := <declare-bodies-top> s
      |}

  declare-bodies:
    Let(d*, b) -> Rec(d'*, b')
    with
      dr-scope-declare-cookies(
        !d*
      ,
        d'* := <map(declare-let-definition)> d*;
        b'  := <declare-bodies-top> b
      )

  declare-let-definition:
    SDefT(x, s*, t*, s) -> SDefT(x', s'*, t'*, s')
    with
      dr-scope-declare-cookies(
        ![s*, t*]
      ,
        x'  := x{<redeclare-definition>};
        s'* := <map(declare-svar)> s*;
        t'* := <map(declare-tvar)> t*;
        s'  := <declare-bodies-top> s
      )

  declare-bodies:
    rec @ Rec(r, b) -> Rec(r', b')
    with
      dr-scope-declare-cookies(
        ![rec]
      ,
        r' := r {<redeclare-definition> rec};
        b' := <declare-bodies-top> b
      )

  declare-bodies:
    Overlay(x, t*, d) -> Overlay(x, t'*, d')
    with
      {| DeclareCookie:
        t'* := <map(declare-tvar)> t*;
        d'  := <declare-bodies-top> d 
      |}

  declare-bodies:
    ScopeDefault(s) -> ScopeDefault(s')
    with
      {| DeclareCookie:
        with(
          tvars;
          list-loop({
            sig := (<id>, 0); scoped-sig := <to-scoped-symbol>sig; rules(DeclareCookie :- scoped-sig)
          })
        );
        s' := <declare-bodies-top> s
      |}

  declare-bodies:
    Scope(v*, s) -> Scope(v*, s')
    with
      {| DeclareCookie:
        <list-loop({ sig := (<id>, 0);scoped-sig:=<to-scoped-symbol> sig;  rules(DeclareCookie :- scoped-sig)})> v*;
        s' := <declare-bodies-top> s
      |}

  declare-bodies:
    Match(t) -> Match(t')
    with
      t' := <declare-match> t

  declare-bodies:
    Rule(t1, t2, w) -> Rule(t1', t2', w')
    with
      t1' := <declare-match> t1;
      w'  := <declare-bodies-top> w;
      t2' := <declare-bodies-top> t2 

  declare-bodies:
    LRule(r) -> LRule(r')
    with
      {| DeclareCookie: // acts as a non-blanking scope
        r' := <declare-bodies-top> r
      |}

  declare-bodies:
    SetDynRule(x, r) -> SetDynRule(x', r')
    with
      {| DeclareCookie: // acts as a non-blanking scope
        x' := <declare-bodies-top> x;
        r' := <declare-bodies-top> r
      |}

  declare-bodies:
    DynRuleScopeId(x) -> DynRuleScopeId(x')
    where
      x' := x{<declare-cookie-of>} 

  declare-bodies:
    LabeledDynRuleScopeId(x, t) -> LabeledDynRuleScopeId(x', t')
    where
      x' := x{<signature-of; getCookie>}; 
      t' := <declare-bodies-top> t

  declare-bodies:
    Assign(t1, t2) -> Assign(t1', t2')
    with
      t2' := <declare-bodies-top> t2;
      t1' := <declare-match> t1

  declare-bodies:
    AM(s, t) -> AM(s', t')
    with
      s' := <declare-bodies-top> s;
      t' := <declare-match> t

  declare-match =
    alltd(?Var(_); declare-var + ?App(_, _) + ?RootApp(_));
    declare-bodies-top

  declare-bodies:
    GuardedLChoice(c, s1, s2) -> GuardedLChoice(c', s1', s2')
    with
      ( c' := <declare-bodies-top> c;
        s1' := <declare-bodies-top> s1)
    \DeclareCookie/
      s2' := <declare-bodies-top> s2

  declare-svar:
    dec @ VarDec(x, t) -> VarDec(x', t)
    with
      cookie := <newterm>;
      x'     := x{cookie};
      scoped-cookie :=<to-scoped-symbol> cookie;
      //TODO FIX : possibly will result in a bug 
      scoped-sig    := <to-scoped-symbol><signature-of>x; // getting scoped symbol of x  
      rules(
	    	DeclareCookie:   scoped-sig -> cookie
	      STRDeclaration: scoped-cookie  -> dec
	    )
	    
  declare-tvar:
    x -> x'
    where
      <is-string> x
    with
      x' := x{<declare-definition> Var(x)}

  declare-tvar:
    VarDec(x, t) -> VarDec(x', t)
    with
      x' := x{<declare-definition>}
      
	//TODO : Check why this rule is failing for var(x)
  declare-var:
    Var(x) -> Var(x')
    with
      x' := x{<declare-definition>}

  declare-bodies:
    Var(x{}) -> Var(x')
    where
      x' := x{<declare-cookie-of>}

rules // Uses inside definition bodies

  declare-bodies:
    CallT(SVar(x), s*, t*) -> CallT(SVar(x'), s'*, t'*)
    with
      x' := x{<declare-cookie-of>}
    <+
      x' := x
    with
      t'* := <declare-bodies-top> t*;
      s'* := <map(declare-bodies-svar <+ declare-bodies-top)> s*

  declare-bodies-svar:
    CallT(SVar(x), [], []) -> CallT(SVar(x'), [], [])
    where
      x' := x{<declare-cookie-of>}
    <+
      fail // TODO: special exception for higher-order args

  declare-bodies:
    Op(x, t*) -> Op(x', t'*)
    where
      x' := x{<declare-cookie-of>}
    with
      t'* := <declare-bodies-top> t*


rules 

	// TODO IMPLEMENT IMPORT handling => needs to be moved to the compile-legacy-artifacts
	// and declare them in GLobal Scope for the furthur analysis
  open-import(to-signatures):
    full-path -> ast
    with
      ast := <id>
  
  declare-str-definition:
    Import(x) -> Import(x)
  	with
	  	if (!x => Name(mName)) then
  			moduleName := mName 
  		else
  			moduleName :=  x 
  		end
  	with 
  		<get-all-declared-entries-by-namespace; map-declarations(declare-stratego-globals-top)>moduleName 
  	<+	
  		<open-import(resolve-import-decl, read-stratego-signatures, declare-stratego-globals-top)> moduleName
    <+
      rules(IsImportedFailed: moduleName)
       

  declare-str-definition:
    ImportWildcard(x) -> ImportWildcard(x)
   	with
	  	if (!x => Name(mName)) then
  			moduleName := mName 
  		else
  			moduleName :=  x 
  		end
  	with 
  		<get-declarations-by-namespace; map-declarations(declare-stratego-globals-top)>moduleName 
  	<+	
  	  <open-wildcard-import(file-exists <+ resolve-import-path, read-stratego-signatures, declare-stratego-globals-top, has-extension(|"str") + has-extension(|"rtree"))> x
    <+
      rules(IsImportedFailed: x)

   resolve-import-decl:
     x -> full-path
     where
       fetch-library-ast; 
       full-path := x 
     <+
       full-path := <resolve-import-path> $[[x].spx]
     <+
       full-path := <resolve-import-path> $[[x].str]
     <+
       full-path := <resolve-import-path> $[[x].rtree]

   resolve-import-path:
     x -> full-path
     where
        // FIXME: fetch true import paths from someplace
   			full-path := <file-exists> $[[<project-path>]/[x]]
     <+ full-path := <file-exists> $[[<project-path>]/trans/[x]]
     <+ full-path := <file-exists> $[[<project-path>]/lib/[x]]
     <+ full-path := <file-exists> $[[<project-path>]/src/[x]]
     <+ full-path := <file-exists> $[[<project-path>]/syntax/[x]]
     <+ full-path := <file-exists> $[[<project-path>]/syn/[x]]
     <+ full-path := <file-exists> $[[<project-path>]/src/syntax/[x]]
 
  fetch-library-ast:
    x -> <pack-stratego-parse-stratego> (IncludeFromPath(x), [])

	
  read-stratego-signatures:
    str -> <to-signatures> file
    where
      file := <fetch-library-ast>str
    <+
      rtree := <guarantee-extension(|"rtree")>;
      if <is-newer> (rtree, str) + not(<file-exists> str) + <has-extension(|"rtree")> str then
        file := <file-exists; ReadFromFile> rtree
      else
        file := <parse-stratego-file> str
      end
	
	to-signatures =
    basic-stratego-desugar-top;
    topdown(try(remove-stratego-bodies))


  remove-stratego-bodies:
    SDefT(x, s*, t*, s) -> SDefT(x, s*, t*, s')
    with
      s' := <collect-all(?RDecT(_, _, _))> s
   
  remove-stratego-bodies:
    Import(_) -> ()
   
  remove-stratego-bodies:
    ImportWildcard(_) -> ()


rules 

	// Content completion
  propose-completion:
    completion -> proposals
    where
      signature-of; one(?COMPLETION(prefix)) <+ one(?COMPLETION(prefix))
    with
      all-signatures := <filter-by-prefix(|prefix)> <all-keys-DeclareCookie>;
      switch !completion
        case ?Var(_):
          all-signatures' := <try(filter(?(_, _)); not([]))> all-signatures
        case ?SVar(_):
          all-signatures' := <filter(?(_, _, _))> all-signatures
        case ?DynRuleScopeId(_):
          all-signatures' := <filter(?(_, _, _); not(is-congruence-signature))> all-signatures
        case ?Import(_):
          all-signatures' := []
        otherwise: // unknown context
          all-signatures' := <filter(not(is-congruence-signature))> all-signatures
      end;
      proposals := <map(signature-to-proposal)> all-signatures';
      rules(
        ContentProposals := proposals
      )
  
  propose-completion:
    Rule(lhs, rhs @ Var(COMPLETION(_)), _) -> proposals
    where
      <not(oncetd(?RootApp(_) + ?App(_, _)))> lhs
    with
      lhs'      := <topdown(try(\As(_, e) -> e\))> lhs;
      proposals := [([<pp-stratego-string> lhs'], "") | <propose-completion> rhs];
      rules(
        ContentProposals := proposals
      )
  
  filter-by-prefix(|prefix) =
    filter(one(string-starts-with(|prefix); not(?"")))
  
  signature-to-proposal:
    (x, 0) -> [x | parentheses]
    with
      if is-constructor then
        parentheses := ["()"]
      else
        parentheses := []
      end

  signature-to-proposal:
    (x, n) -> [x, "(", t*, ")"]
    where
      <gt> (n, 0)
    with
      t* := <separate-by(|", ")> <copy> (n, "t") // TODO: number (Spoofax/231)

  signature-to-proposal:
    (x, 0, 0) -> [x, ""]

  signature-to-proposal:
    (x, n, 0) -> [x, "(", t*, ")"]
    where
      <gt> (n, 0)
    with
      t* := <separate-by(|", ")> <copy> (n, "s")

  signature-to-proposal:
    (x, n, m) -> [x, "(", s*, "|", t*, ")"]
    where
      <gt> (m, 0)
    with
      s* := <separate-by(|", ")> <copy> (n, "s");
      t* := <separate-by(|", ")> <copy> (m, "t")

  signature-to-proposal:
    (x, [DR_DUMMY()], [DR_DUMMY()]) -> x // strategy param (wildcard arity)

	
rules 
	// Projections and lookup
	analyze-str-ast:
		(ast, path, project-path) -> ast'
		with
			enable-stratego-debugging
			;rules(
        		CurrentFileFullPath := $[[project-path]/[path]]
        )
      ;<try(get-source-base-dir)>ast
   		;if <file-exists> $[[project-path]/.disable-global-analysis] then
    		rules(NoAnalysis: _)
    	end
   		;if <file-exists> $[[project-path]/.warn-global-analysis] then
    		rules(WarnAnalysis: _)
    	end
    with
    	declare-stratego-globals-top //TODO  : Refactor globals-top. Rewriting of the tree is done here.
     	;ast' := <declare-bodies-top>;
      rules(
        DecoratedAst := ast'
      )
    where 
    	disable-stratego-debugging
    	;<debug-str> $[AST after analysis : [<pp-aterm>ast']]
   
