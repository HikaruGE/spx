module context/str/declare

imports
	libstrc		
	libstratego-lib
 	libstratego-gpp
	libstratego-aterm
imports
	lib/editor-common.generated
	include/SpoofaxLang
imports	
	utils/sourcedir
 	utils/debug
 	utils/contract
 	utils/annotations
 	common 
	config 
imports 
	context/-
	normalize/-
	context/str/signature-generator
	spoofaxlang  

rules 
	verify-declared-stratego = 
		remove-annotations;
	 	verify(String | <id> , "String @is-declared-stratego"); 
		<verify-symbol-exists>(<id> , STRSignature())
	<+
    dbg-analysis(! $[Failed verify-declared-stratego  id [<print-as-string>]] 
                      | "STR|verify-declared-stratego" , "Warning" )  
    ; fail
	
	is-declared-stratego(s) = 	
		 one(
        ( ?<id>
        + ?SVar(<id>))
        ; resolve-str-signatures
        ; filter(s)
        ; is-not-empty-list  
     )
 
rules 
	//TODO fix : also check derieved signatures 
	is-constructor =
    (?(_, _); resolve-str-cookie; resolve-str-declaration <+ declaration-of);
    (?OpDecl(_, _) + ?ExtOpDecl(_, _))
    
    //TODO FIX: 
    //<+ ?(name, #of arguments) ; gets signature contructor from declare - signature ; verify it has the same arity 
  
  is-congruence-signature:
    (x, s, 0) -> (x, s, [])
    where
      <resolve-str-cookie> (x, s)   
  
  declare-cookie-of =
    signature-of
    ; resolve-str-cookie
    
  declaration-of =
    signature-of 
    ; (  ?_{<resolve-str-declaration>} 
  	 	<+ ?(_{<resolve-str-declaration>}, _) 
  	 	<+ ?(_{<resolve-str-declaration>}, _, _)
 	  )
 	 
 
rules 
  
  // TODO : get-rid of scoping symbol as it is automatically handle in new symboltable structure  
  declare-definition:
    def -> cookie
    with
      sig := <signature-of>
      ; scoped-sig    :=<to-scoped-symbol> sig
      ; if not(<DeclareCookie>scoped-sig  <+ <resolve-str-cookie> sig) then
          cookie := <newterm>
          ; scoped-cookie :=<to-scoped-symbol> cookie
          ; rules(
              DeclareCookie:  scoped-sig  -> cookie
              STRDeclaration: scoped-cookie  -> def
            )
		      ; dbg-declaration(! $[Storing DeclareCookie : [<print-as-string>scoped-sig] -> [<print-as-string>cookie]]
		                        | "STR|declare-definition" , <debug-level-INFO> ) 
				  ; dbg-declaration(! $[Storing STRDeclaration : [<print-as-string>scoped-cookie] -> [<print-as-string>def]]  
				    								| "STR|declare-definition" , <debug-level-INFO> )      
      else
       	  cookie := <resolve-str-cookie> sig 
      end
		

  redeclare-definition:
    def -> cookie
    with sig := <signature-of>
      ; cookie := <newterm>
      ; scoped-cookie :=<to-scoped-symbol> cookie
      ; scoped-sig    :=<to-scoped-symbol> sig
      ; rules(
         DeclareCookie:  scoped-sig    -> cookie
         STRDeclaration: scoped-cookie -> def
       )
   where
   	dbg-declaration(! $[Storing DeclareCookie : [<print-as-string>scoped-sig] ->    [<print-as-string>cookie]]  
				    								| "STR|redeclare-definition" , <debug-level-INFO> )
		; dbg-declaration(! $[Storing STRDeclaration : [<print-as-string>scoped-cookie] -> [<print-as-string>def]]  
				    								| "STR|redeclare-definition" , <debug-level-INFO> )
				    										    						       
  
  external SRTS-EXT-newint(|)


rules 
  
  index-str-declarations = 
    dbg-declaration(! $[indexing Stratego Declarations : [<print-as-string><all-keys-STRDeclaration>]]  
    								| "STR|index-str-declarations " , <debug-level-INFO> );
		<list-loop(
        { 
          ?cookie
          // Indexing (cookie, STRDef) -> StrDefinition
          ; dbg-declaration(! $[Indexing: [<print-as-string>cookie] -> STRDef()  ->  [<print-as-string><STRDeclaration>cookie]] | "STR|index-str-declarations " , <debug-level-INFO> ) 
          ; <index-symbol-definition>(cookie, STRDef() ,  <STRDeclaration>cookie)
        } 
      )><all-keys-STRDeclaration>
      
  
  //TODO FIX : strip all the scope . Better not to enclode it with scope.
  index-str-cookies =      
  	dbg-declaration(! $[indexing Stratego cookies  : [<print-as-string><all-keys-DeclareCookie>]]  
    								| "STR|index-str-cookies" , <debug-level-INFO> );
    <list-loop(
	    { ?sig
	      // Indexing (sig, StrCookie) -> cookie 
	      ; dbg-declaration(! $[Indexing: [<print-as-string>sig] -> STRCookie() ->  [<print-as-string><DeclareCookie>sig]] | "STR|index-str-cookies" , <debug-level-INFO>)  
	      ; <index-symbol-definition>(sig, STRCookie() ,  <DeclareCookie>sig)
	      ; <remove-scope-from-symbol; ?sig'; signature-to-declaration-id>sig => str-id
	      ; dbg-declaration(! $[Indexing: [<print-as-string>str-id] -> STRSignature() ->  [<print-as-string>sig]] | "STR|index-str-cookies" , <debug-level-INFO>)
        ; <index-symbol-definition>(str-id, STRSignature() , sig')  
	    }
    )><all-keys-DeclareCookie>  
 
  resolve-str-declaration =
    ? cookie
  	; ( <STRDeclaration> <to-scoped-symbol> cookie
	  	<+
    		<resolve-symbol-definition>( <id>, STRDef())
    		; dbg-declaration(!$[[<print-as-string>cookie] -> STRDef() ->  [<print-as-string><id>]] | "STR|resolve-str-declaration" , <debug-level-INFO> )
    	)	   
  <+
    dbg-declaration(!$[Failed to retrive STRDef for cookie [<print-as-string><to-scoped-symbol>]]| "STR|resolve-str-declaration" , "Warning" ) 
    ; fail
    
  resolve-str-cookie =
    ?sig ;
    (	<DeclareCookie> <to-scoped-symbol> sig 
    	<+	
    	<resolve-symbol-definition>( <id>, STRCookie())
    	; dbg-declaration(! $[resolve-str-cookie: [<print-as-string>sig] -> STRCookie() ->  [<print-as-string><id>]] | "STR|resolve-str-cookie" , <debug-level-INFO>)
    )  
  <+
    dbg-declaration(!$[Failed to retrive STRCookie for signature [<print-as-string><to-scoped-symbol>]]| "STR|resolve-str-cookie" , "Warning") 
    ; fail
  
  resolve-str-signatures =
    ?key
    ; verify(String | key , "String @resolve-str-signatures")
    ; <resolve-all-symbol-definitions>( <id>, STRSignature())
    ; dbg-declaration(! $[[<print-as-string>key] -> STRSignature() ->  [<print-as-string><id>]] 
                      | "STR|resolve-str-signatures" , <debug-level-INFO> )
  <+
    dbg-declaration(! $[Failed to retrive STRSignatures* for id [<print-as-string><to-scoped-symbol>]] 
                      | "STR|resolve-str-signatures" , "Warning" )
    ; fail
      
  resolve-str-signature =
    ?key
    ; verify(String | key , "String @resolve-str-signatures")
		; <resolve-symbol-definition>( <id>, STRSignature())
  	; dbg-declaration(! $[resolve-str-signature: [<print-as-string>key] -> STRSignature() ->  [<print-as-string><id>]] 
	                      | "STR|resolve-str-signature" , <debug-level-INFO> )  
  <+
    dbg-declaration(! $[Failed to retrive STRSignature for id [<print-as-string><to-scoped-symbol>]] 
                      | "STR|resolve-str-signature" , "Warning" )  
    ; fail 
  
rules
  declare-legacy-str-imports = 
    activate-global-scope(
      declare-rules(declare-stratego-globals-top)
    )
     
  // declare all the strategy the rule definition inside 
  // current rules or strategies block. 
  // inaddition it also stores it in the symbol table.
  declare-rules(s) = 
    ?list-str-def*
    ; dbg-declaration(! "------------new str analysis" | "STR" , <debug-level-INFO>) 
    ; with-spxverify(
	     {| DeclareCookie,  STRDeclaration
	      : <s>list-str-def* => analyzed-str-defs*
	      ; index-str-declarations
	      ; index-str-cookies
	      |} 
      )
  	; !analyzed-str-defs*
  
  // Activating internal scope for the current enclosing package 
  // it actually overrides current module scope and activate 
  // internal scope to store internal strategies and rules 
  activate-stratego-internal-scope(s) =
	activate-internal-scope( 
    	declare-rules(s)
  	) 
      
strategies 
	
	declare-stratego-globals-top = alltd(declare-str-definition) 
   
rules

  // Analyzing all the rules and strategies block and store the Declarations  
  // in symbol table.
  declare-str-definition : 
    InternalStrategies(str-defs*) -> InternalStrategies(analyzed-str-defs*)
    where 
      <activate-stratego-internal-scope(declare-stratego-globals-top)>str-defs*  =>analyzed-str-defs*

  declare-str-definition : 
    InternalRules(str-defs*) -> InternalRules(analyzed-str-defs*)
    where 
      <activate-stratego-internal-scope(declare-stratego-globals-top)>str-defs*  =>analyzed-str-defs*

  declare-str-definition : 
    Rules(str-defs*) -> Rules(analyzed-str-defs*)
    where 
      <declare-rules(declare-stratego-globals-top)>str-defs*  =>analyzed-str-defs* 

  declare-str-definition : 
    Strategies(str-defs*) -> Strategies(analyzed-str-defs*)
    where 
      <declare-rules(declare-stratego-globals-top)>str-defs*  =>analyzed-str-defs*

       
rules
  
  declare-str-definition:
    SDefT(x, s*, t*, s) -> SDefT(x', s*, t*, s')
    with
    	x' := x{<declare-definition>};
      s' := <topdown(try(declare-dynrule))> s
	
	declare-str-definition:
    OpDecl(x, t) -> OpDecl(x', t)
    with
      cookie := <redeclare-definition>;
      x'     := x{cookie}
    with
      // Declare congruence
      (x'', n) := <signature-of>;
      sig'     := (x'', n, 0);
      scoped-sig'  :=<to-scoped-symbol> sig';
      rules(
        DeclareCookie: scoped-sig' -> cookie
      )
    where
    	dbg-declaration(! $[declare-str-definition [<print-as-string>]| Storing DeclareCookie : [<print-as-string>scoped-sig'] -> [<print-as-string>cookie]] | "STR" , <debug-level-INFO> )  
  
   declare-str-definition:
    ExtSDef(x, s*, t*) -> <id>
    with
      redeclare-definition
	
  declare-str-definition:
    ExtOpDecl(x, t) -> <id>
    with
     redeclare-definition
	
  declare-str-definition:
    Overlay(x, t, d) -> Overlay(x', t, d)
    with
      cookie := <redeclare-definition>;
      x'     := x{cookie}
    with
      // Declare congruence
      (x'', n)     := <signature-of>;
      sig'         := (x'', n, 0);
      scoped-sig'  :=<to-scoped-symbol> sig';
      rules(
        DeclareCookie: scoped-sig'   -> cookie
      )
    where
    	dbg-declaration(!$[declare-str-definition [<print-as-string>] | Storing DeclareCookie : [<print-as-string>scoped-sig'] -> [<print-as-string>cookie]] | "STR" , <debug-level-INFO> )
    	
    
  declare-dynrule:
    dec @ RDecT(x, s*, t*) -> RDecT(x', s*, t*)
    where
      not(!x => COMPLETION(_))
    with
    	x' := x{<declare-cookie-of>}
    <+
      cookie := <newterm>;
      x'  := x{cookie};
      s'* := <length> s*;
      t'* := <length> t*;
      sig := (x, s'*, t'*);
      scoped-cookie :=<to-scoped-symbol> cookie;
      scoped-sig    :=<to-scoped-symbol> sig;
      scoped-x      :=<to-scoped-symbol> x;
      rules(
        DeclareCookie:  scoped-sig    -> cookie
        DeclareCookie:  scoped-x      -> cookie
        STRDeclaration: scoped-cookie -> dec
      );
      // See https://svn.strategoxt.org/repos/StrategoXT/strategoxt/trunk/strc-core/lib/stratego/strc/front/lift-dynamic-rules.str
      <declare-dr-rule(|x, cookie, 0, 2)> "new";
      <declare-dr-rule(|x, cookie, 0, 1)> "undefine";
      <declare-dr-rule(|x, cookie, s'*, <inc> t'*)> "aux";   // FIXME: dependent on number of free variables in lhs
      <declare-dr-rule(|x, cookie, <inc> s'*, t'*)> "reverse-bagof";
      <declare-dr-rule(|x, cookie, 1, 0)> "innermost-scope";
      <map(declare-dr-rule(|x, cookie, s'*, <inc> t'*))>
        ["break-to-label","continue-to-label"];
      <declare-dr-rule(|x, cookie, <inc> s'*, <inc> t'*)> "throw";
      <map(declare-dr-rule(|x, cookie, <inc> s'*, t'*))>
        ["fold", "bigfold"];
      <map(declare-dr-rule(|x, cookie, s'*, t'*))>
        ["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", "continue", "chain", "bigchain"]

   declare-dr-rule(|x,cookie,s,t) =
   	?prefix
    ; sig := ($[[prefix]-[x]], s, t)
    ; scoped-sig := <to-scoped-symbol> sig
    ; rules(DeclareCookie: scoped-sig -> cookie)
		; dbg-declaration(! $[declare-dr-rule [<print-as-string>prefix]| Storing DeclareCookie : [<print-as-string>scoped-sig] -> [<print-as-string>cookie]]
		                  | "STR" , <debug-level-INFO> )  
  
strategies 
  
  // Declarations inside definition bodies , i.e., analyzing strategies local declarations
  declare-str-local-definition-main =  declare-bodies-top 
  
  declare-bodies-top = alltd(declare-bodies)

rules
    
  declare-bodies: 
    InternalRules(str-defs*) -> InternalRules(analyzed-str-defs*)
    where 
      <activate-stratego-internal-scope(
          declare-bodies-top
        )
      >str-defs*  =>analyzed-str-defs*
       

  declare-bodies: 
    InternalStrategies(str-defs*) -> InternalStrategies(analyzed-str-defs*)
    where
	    <activate-stratego-internal-scope(
          declare-bodies-top
        )
      >str-defs*  =>analyzed-str-defs*
             
  declare-bodies: 
    Rules(str-defs*) -> Rules(analyzed-str-defs*)
    where 
      <declare-rules(declare-bodies-top)>str-defs*  =>analyzed-str-defs* 

  declare-bodies: 
    Strategies(str-defs*) -> Strategies(analyzed-str-defs*)
    where 
      <declare-rules(declare-bodies-top)>str-defs*  =>analyzed-str-defs*

rules
        
  declare-bodies:
    SDefT(x, s*, t*, s) -> SDefT(x, s'*, t'*, s')
    with
      {| DeclareCookie:
        s'* := <map(declare-svar)> s*;
        t'* := <map(declare-tvar)> t*;
        s'  := <declare-bodies-top> s
      |}

  declare-bodies:
    Let(d*, b) -> Rec(d'*, b')
    with
      dr-scope-declare-cookies(
        !d*
      ,
        d'* := <map(declare-let-definition)> d*;
        b'  := <declare-bodies-top> b
      )

  declare-let-definition:
    SDefT(x, s*, t*, s) -> SDefT(x', s'*, t'*, s')
    with
      dr-scope-declare-cookies(
        ![s*, t*]
      ,
        x'  := x{<redeclare-definition>};
        s'* := <map(declare-svar)> s*;
        t'* := <map(declare-tvar)> t*;
        s'  := <declare-bodies-top> s
      )

  declare-bodies:
    rec @ Rec(r, b) -> Rec(r', b')
    with
      dr-scope-declare-cookies(
        ![rec]
      ,
        r' := r {<redeclare-definition> rec};
        b' := <declare-bodies-top> b
      )

  declare-bodies:
    Overlay(x, t*, d) -> Overlay(x, t'*, d')
    with
      {| DeclareCookie:
        t'* := <map(declare-tvar)> t*;
        d'  := <declare-bodies-top> d 
      |}

  declare-bodies:
    ScopeDefault(s) -> ScopeDefault(s')
    with
      {| DeclareCookie:
        with(
          tvars;
          list-loop(
            {
              sig := (<id>, 0)
              ; scoped-sig := <to-scoped-symbol>sig
              ; rules(DeclareCookie :- scoped-sig)
            }
          )
        );
        s' := <declare-bodies-top> s
      |}

  declare-bodies:
    Scope(v*, s) -> Scope(v*, s')
    with
      {| DeclareCookie:
        <list-loop(
	          { 
	            sig := (<id>, 0)
	            ; scoped-sig:=<to-scoped-symbol> sig
	            ; rules(DeclareCookie :- scoped-sig)
	          }
          )> v*
          ;s' := <declare-bodies-top> s
      |}
        
  declare-bodies:
    Match(t) -> Match(t')
    with
      t' := <declare-match> t

  declare-bodies:
    Rule(t1, t2, w) -> Rule(t1', t2', w')
    with
      t1' := <declare-match> t1;
      w'  := <declare-bodies-top> w;
      t2' := <declare-bodies-top> t2 

  declare-bodies:
    LRule(r) -> LRule(r')
    with
      {| DeclareCookie: // acts as a non-blanking scope
        r' := <declare-bodies-top> r
      |}

  declare-bodies:
    SetDynRule(x, r) -> SetDynRule(x', r')
    with
      {| DeclareCookie: // acts as a non-blanking scope
        x' := <declare-bodies-top> x;
        r' := <declare-bodies-top> r
      |}

  declare-bodies:
    DynRuleScopeId(x) -> DynRuleScopeId(x')
    where
      x' := x{<declare-cookie-of>} 

  declare-bodies:
    LabeledDynRuleScopeId(x, t) -> LabeledDynRuleScopeId(x', t')
    where
      x' := x{<signature-of; resolve-str-cookie>}; 
      t' := <declare-bodies-top> t

  declare-bodies:
    Assign(t1, t2) -> Assign(t1', t2')
    with
      t2' := <declare-bodies-top> t2;
      t1' := <declare-match> t1

  declare-bodies:
    AM(s, t) -> AM(s', t')
    with
      s' := <declare-bodies-top> s;
      t' := <declare-match> t

  declare-match =
    alltd(?Var(_); declare-var + ?App(_, _) + ?RootApp(_));
    declare-bodies-top

  declare-bodies:
    GuardedLChoice(c, s1, s2) -> GuardedLChoice(c', s1', s2')
    with
      ( c' := <declare-bodies-top> c;
        s1' := <declare-bodies-top> s1)
    \DeclareCookie/
      s2' := <declare-bodies-top> s2

  declare-svar:
    dec @ VarDec(x, t) -> VarDec(x', t)
    with
      cookie := <newterm>;
      x'     := x{cookie};
      scoped-cookie := <to-scoped-symbol> cookie;
      scoped-sig    := <to-scoped-symbol><signature-of>x;   
      rules(
	    	DeclareCookie:   scoped-sig -> cookie
	      STRDeclaration:  scoped-cookie  -> dec
	    );
	    // HACK: a higher-order strategy can be passed as an argument, 
      // as in s1(s2), where s2 has arguments.
      // We overwrite (in local scope) global strategies with signature ?(x,_,_)
      // Fixes Bug: a{1} = fail; foo(a{2}) = a{2} //NOT a{1}
      <resolve-str-signatures> x; 
      filter(declare-svar-signatures(|cookie, x))
    
  
  declare-svar-signatures(|cookie, svar-name):
    key@(svar-name,_ ,_) -> key
    where 
      scoped-sig    := <to-scoped-symbol>key
    where
      rules (DeclareCookie: scoped-sig -> cookie)
   
	    
  declare-tvar:
    x -> x'
    where
      <is-string> x
    with
      x' := x{<declare-definition> Var(x)}

  declare-tvar:
    VarDec(x, t) -> VarDec(x', t)
    with
      x' := x{<declare-definition>}
  
  declare-var:
    Var(x) -> Var(x')
    with
      x' := x{<declare-definition>}

  declare-bodies:
    Var(x{}) -> Var(x')
    where
      x' := x{<declare-cookie-of>}
rules 
  // Uses inside definition bodies
  declare-bodies:
    CallT(SVar(x), s*, t*) -> CallT(SVar(x'), s'*, t'*)
    with
      x' := x{<declare-cookie-of>}
    <+
      x' := x
    with
      t'* := <declare-bodies-top> t*;
      s'* := <map(declare-bodies-svar <+ declare-bodies-top)> s*

  declare-bodies-svar:
    CallT(SVar(x), [], []) -> CallT(SVar(x'), [], [])
    where
      x' := x{<declare-cookie-of>}
    <+
      // HACK: a higher-order strategy can be passed as an argument, 
      // as in s1(s2), where s2 has arguments. We can only check if there
      // is a strategy called s2, independent of the number of
      // (strategy/term) arguments to s2.
      // map(to-java) => Call(SVar("map"), [CallNoArgs(SVar("to-java"))])
      <resolve-str-signatures>x
      ; filter(?(x,_,_))
      ; fetch-elem(\key@(x, s*, t*) -> <resolve-str-cookie>\)
      ; x' := x{<id>}
      

  declare-bodies:
    Op(x, t*) -> Op(x', t'*)
    where
      x' := x{<declare-cookie-of>}
    with
      t'* := <declare-bodies-top> t*

rules 
  dr-scope-declare-cookies(defs, s):
    t -> t'
    with
      defs        := <defs>;
      old-cookies := <map(!(<signature-of>, <declare-cookie-of <+ !()>))>;
      t'          := <s> t;
      <list-loop(
        { ?(sig, cookie);
          if !cookie => () then
            scoped-sig    :=<to-scoped-symbol> sig;
            rules(DeclareCookie :- scoped-sig)
          else
            scoped-sig    :=<to-scoped-symbol> sig;
            rules(DeclareCookie : scoped-sig -> cookie)
          end
        })
      >old-cookies
rules 

	// TODO IMPLEMENT IMPORT handling => needs to be moved to the compile-legacy-artifacts
	// and declare them in GLobal Scope for the furthur analysis
  open-import(to-signatures):
    full-path -> ast
    with
      ast := <id>
  
  //TODO fix : remove obsolete constructs imports . In legacy str , we dont support transitive imports
  //hence, in declare str , we dont require to handle imports .
  declare-str-definition:
    Import(x) -> Import(x)
 	with
	  	if (!x => Name(mName)) then
  			moduleName := mName 
  		else
  			moduleName :=  x 
  		end
  	with 
  		<open-import(resolve-import-decl, read-stratego-signatures, declare-stratego-globals-top)> moduleName
    <+
      rules(IsImportedFailed: moduleName)
 
  declare-str-definition:
    ImportWildcard(x) -> ImportWildcard(x)
   	with
	  	if (!x => Name(mName)) then
  			moduleName := mName 
  		else
  			moduleName :=  x 
  		end
  	with 
  	  <open-wildcard-import(file-exists <+ resolve-import-path, read-stratego-signatures, declare-stratego-globals-top, has-extension(|"str") + has-extension(|"rtree"))> x
    <+
      rules(IsImportedFailed: x)

   
   resolve-import-decl:
     x -> full-path
     where
       fetch-library-ast; 
       full-path := x 
     <+
       full-path := <resolve-import-path> $[[x].spx]
     <+
       full-path := <resolve-import-path> $[[x].str]
     <+
       full-path := <resolve-import-path> $[[x].rtree]

   resolve-import-path:
     x -> full-path
     where
        // FIXME: fetch true import paths from someplace
   			full-path := <file-exists> $[[<get-project-path>]/[x]]
     <+ full-path := <file-exists> $[[<get-project-path>]/trans/[x]]
     <+ full-path := <file-exists> $[[<get-project-path>]/lib/[x]]
     <+ full-path := <file-exists> $[[<get-project-path>]/src/[x]]
     <+ full-path := <file-exists> $[[<get-project-path>]/syntax/[x]]
     <+ full-path := <file-exists> $[[<get-project-path>]/syn/[x]]
     <+ full-path := <file-exists> $[[<get-project-path>]/src/syntax/[x]]
 
  fetch-library-ast:
    x -> <pack-stratego-parse-stratego> (IncludeFromPath(x), [])

	
  read-stratego-signatures:
    str -> <to-signatures> file
    where
      file := <fetch-library-ast>str
    <+
      rtree := <guarantee-extension(|"rtree")>;
      if <is-newer> (rtree, str) + not(<file-exists> str) + <has-extension(|"rtree")> str then
        file := <file-exists; ReadFromFile> rtree
      else
        file := <parse-stratego-file> str
      end
	
	to-signatures =
    basic-stratego-desugar-top;
    topdown(try(remove-stratego-bodies))


  remove-stratego-bodies:
    SDefT(x, s*, t*, s) -> SDefT(x, s*, t*, s')
    with
      s' := <collect-all(?RDecT(_, _, _))> s
   
  remove-stratego-bodies:
    Import(_) -> ()
   
  remove-stratego-bodies:
    ImportWildcard(_) -> ()


rules 

	// Content completion
  propose-completion:
    completion -> proposals
    where
      signature-of; one(?COMPLETION(prefix)) <+ one(?COMPLETION(prefix))
    with
      all-signatures := <filter-by-prefix(|prefix)> <all-keys-DeclareCookie>;
      switch !completion
        case ?Var(_):
          all-signatures' := <try(filter(?(_, _)); not([]))> all-signatures
        case ?SVar(_):
          all-signatures' := <filter(?(_, _, _))> all-signatures
        case ?DynRuleScopeId(_):
          all-signatures' := <filter(?(_, _, _); not(is-congruence-signature))> all-signatures
        case ?Import(_):
          all-signatures' := []
        otherwise: // unknown context
          all-signatures' := <filter(not(is-congruence-signature))> all-signatures
      end;
      proposals := <map(signature-to-proposal)> all-signatures'
  
  propose-completion:
    Rule(lhs, rhs @ Var(COMPLETION(_)), _) -> proposals
    where
      <not(oncetd(?RootApp(_) + ?App(_, _)))> lhs
    with
      lhs'      := <topdown(try(\As(_, e) -> e\))> lhs;
      proposals := [([<pp-stratego-string> lhs'], "") | <propose-completion> rhs]
      
  
  filter-by-prefix(|prefix) =
    filter(one(string-starts-with(|prefix); not(?"")))
  
  //TODO fix for spoofaxlang
  
  signature-to-proposal:
    (x, 0) -> [x | parentheses]
    with
      if is-constructor then
        parentheses := ["()"]
      else
        parentheses := []
      end

  signature-to-proposal:
    (x, n) -> [x, "(", t*, ")"]
    where
      <gt> (n, 0)
    with
      t* := <separate-by(|", ")> <copy> (n, "t") // TODO: number (Spoofax/231)

  signature-to-proposal:
    (x, 0, 0) -> [x, ""]

  signature-to-proposal:
    (x, n, 0) -> [x, "(", t*, ")"]
    where
      <gt> (n, 0)
    with
      t* := <separate-by(|", ")> <copy> (n, "s")

  signature-to-proposal:
    (x, n, m) -> [x, "(", s*, "|", t*, ")"]
    where
      <gt> (m, 0)
    with
      s* := <separate-by(|", ")> <copy> (n, "s");
      t* := <separate-by(|", ")> <copy> (m, "t")

  signature-to-proposal:
    (x, [DR_DUMMY()], [DR_DUMMY()]) -> x // strategy param (wildcard arity)

	