module to-str

imports
  libstratego-lib
  libstrc
  lib/editor-common.generated
  include/SpoofaxLang
imports
  codegen/template/to-str
  context/template/declare
  normalize/signatures

strategies

  test-templatelang-to-stratego =
    let err(|msg) = debug(!msg); fail

        // Parse a string containing some template productions.
        prepare-input = {x:
          (<parse-spoofaxlang-string> <conc-strings> ("module x templates ", <id>)
            <+ err(|"parse failed : "));
          (?CompilationUnit([Module(_, _, x)])
            <+ err(|"project failed : "));
          !x
        }

        prepare-output = id

        // Run a test on a tuple (input, expected-output).
        // Input is a string containing template productions.
        // Output is a Stratego AST as build by |[ ]| CS embedding.
        test' = {input, expected-output, actual-output:
          where(?(<id>, _); all-lines(<conc-strings> ("  ", <id>)); debug);
          (prepare-input, prepare-output) => (input, expected-output);
          (<template-sections-to-stratego> input => actual-output
            <+ err(|"template-sections-to-stratego failed : "));
          // Instead of checking for exact equality we check that the output appears within the input.
          // This way boilerplate parts can be left out in the majority of the tests.
          (<oncetd(?expected-output)> actual-output
            <+ <debug> "actual output of template-sections-to-stratego does not match expected output!";
               <debug(!"actual   : ")> /*<pp-stratego-string> <parenthesize-Stratego>*/ actual-output;
               <debug(!"expected : ")> /*<pp-stratego-string> <parenthesize-Stratego>*/ expected-output;
               fail)
        }

        test-placeholders =
          <test'> ($[X.Y = <<<Z>>>],
            |[ prettyprint-X: Y(a) -> zz
               with a' := <prettyprint-Z> a;
                    zz := <concat-strings> [a'] ]|);
          <test'> ($[X.Y = <<<this text is ignored : Z>>>],
            |[ prettyprint-X: Y(a) -> zz
               with a' := <prettyprint-Z> a;
                    zz := <concat-strings> [a'] ]|);
          // We got the hang of it; just test whether the varying part looks correct.
          <test'> ($[X.Y = <<<Z?>>>],
            |[ a' := <pp-option(prettyprint-Z)> a ]|);
          <test'> ($[X.Y = <<<Z+>>>],
            |[ a' := <pp-list(prettyprint-Z|" ")> a ]|);
          <test'> ($[X.Y = <<<Z*>>>],
            |[ a' := <pp-list(prettyprint-Z|" ")> a ]|);
          <test'> ($[X.Y = <<<Z+; separator=", ">>>],
            |[ a' := <pp-list(prettyprint-Z|", ")> a ]|);
          <test'> ($[X.Y = <<<Z*; separator=" + ">>>],
            |[ a' := <pp-list(prettyprint-Z|" + ")> a ]|)

        with-newlines(s) = {|Options: {x:
          ?x; rules( Options :+ Newlines() -> x ); s
        }|}

    in with({|DeclaredModule, GetEnclosingModuleName, Options:
      <debug> "test suite: TemplateLang->Stratego";

      // Default
      rules(
        DeclaredModule :+ "__test" -> "__test"
        GetEnclosingModuleName := Module("__test")
        Options :+ Newlines() -> None()
      );
      newlines := [None(), Leading(), Trailing()];

      // Test placeholders.
      <list-loop(with-newlines(test-placeholders))> newlines;

      // Test a complete statement.
      statement := $[
        Statement.IfThen = <<
          if <Exp> then
            <Statement*; separator="\n">
          end
        >>];

      statement-no-newlines-output := |[
        prettyprint-Statement: IfThen(a, b) -> zz
        with a' := <prettyprint-Exp> a;
             b' := <pp-list(prettyprint-Statement|"\n")> b;
             zz := <concat-strings> ["if ", a', " then", <pp-ih(|"\n  ")> b', "\nend"]
      ]|;
      statement-leading-newlines-output := |[
             zz := <concat-strings> ["\nif ", a', " then", <pp-ih(|"\n  ")> b', "\nend"]
      ]|;
      statement-trailing-newlines-output := |[
             zz := <concat-strings> ["if ", a', " then\n", <pp-ih(|"  ")> b', "end\n"]
      ]|;

      !None()    ; with-newlines(<test'> (statement, statement-no-newlines-output));
      !Leading() ; with-newlines(<test'> (statement, statement-leading-newlines-output));
      !Trailing(); with-newlines(<test'> (statement, statement-trailing-newlines-output));

      // Test that undeclared sorts get a trivial prettyprinting strategy.
      // (And undeclared sorts only, hence the inclusion of the whole section.)
      <test'> (statement, |[
        strategies
          prettyprint-Exp = is-string
      ]|);

      <debug> "TemplateLang->Stratego tests finished."
    |})
    end
