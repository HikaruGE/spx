module utils/cache
imports 
	common 
	lib/editor-common.generated 
	utils/path
	utils/debug
	config
	
rules
  open-spx-compilation-unit(resolve-spx-path, resolve-cache-path, parse-file, precompile):
    path -> spx-compilation-unit
    with
    	full-path := <resolve-spx-path>path;
    	cache-path := <resolve-cache-path> full-path;
    	path' := <get-normalized-path> full-path;
    	if not(<CachedCompilationUnit> full-path) then
      	if not( spx-compilation-unit:=  <CachedParseAst> <string-replace(|"\\", "/")>full-path) then
					if <is-newer> (cache-path, path) then
          	// Cache is still valid. 
          	spx-compilation-unit := <ReadFromFile> cache-path
          else
          	// Invalid cache. So reading it from actual source and parsing it. 
          	spx-compilation-unit := <parse-file> full-path;
            if <file-exists> full-path then
            	// Only cache if on filesystem (e.g., ignore libstratego-lib)
              <WriteToBinaryFile> (cache-path, spx-compilation-unit)
              // Marking this compilation unit for 
          		// seperate compilation.
          		;rules ( 
 			  				modified-compilation-units: path'    
 			  			)
            end
          end
 				end;
 				//TODO : delete the following dynamic rules since it is no longer used
 				rules (
 			  	CachedCompilationUnit: path' -> (cache-path,spx-compilation-unit)
 			  );
 			  {| currently-precompiling-spx-abspath:
 			  			rules ( 
 			  				currently-precompiling-spx-abspath := path'  
 			  			); 
 			  			
 			  			<precompile <+ throw-precompile-exception>spx-compilation-unit	
 			  |}
 			end
  	where 
  		<debug-compiler>$[Caching |Storing CompilationUnit: [<pp-aterm>full-path]]

rules 
	get-normalized-path = string-replace(|"\\", "/")
	
	cache-lib-ast : a@( name , ast) -> a
	where
		<spx-lib-cache-path> name => lib-cache-path
	where
		<WriteToBinaryFile> (lib-cache-path, ast)
	
	get-cached-lib-ast(read-lib) : name -> ast
		with
			<spx-lib-cache-path> name => cache-path
		where
			if not(invalidate-lib-cache) then
			 	<debug-compiler>$[Caching | Cache is invalidated for [name]. read it.];
	     	fail	 
	     else
				if <file-exists> cache-path then
				 	<debug-compiler>$[Caching | lib Cache is still valid  for [name]]
				 	;<ReadFromFile> cache-path => ast
				 	;<debug-compiler>$[Caching | Found ast [name].]
				else
					<read-lib>name => ast
					;<cache-lib-ast>( name , ast) 		 
				end
			 end     
rules
	cache-semantic-issues: (abs-path ,issues) ->(abs-path ,issues)
	where
		<debug-compiler>$[Caching | Storing in Cache : [<pp-aterm>]]
	where 	
		<spx-semantic-issues-cache-path> abs-path => cache-path;
		<debug-compiler>$[Caching | Cache Path  :[<pp-aterm>]]
	where 	 
	  <WriteToBinaryFile> (cache-path, issues)
  
	get-cached-semantic-issues : abs-path ->issues
		where
			<spx-semantic-issues-cache-path> abs-path => cache-path 
			;if <is-newer> (cache-path, abs-path)then
			 	<debug-compiler>$[Caching | Cache is still valid  :[<pp-aterm>]]
			 	;<ReadFromFile> cache-path => issues
			 	;<debug-compiler>$[Caching | Found Issues:[<pp-aterm>]]
	     else
				<debug-compiler>$[Caching | Cache is invalidated. Going in the hard way.];
	     	fail		
	     end     
		
	    
rules
	// caching currently analyzing AST so that we don't have to read it again from the file and to use it later on. 
	cache-currently-analyzing-ast = 
		(?(path, compilation-unit-ast) <+ throw-invalid-argument-exception(|"utils.cache.cache-currently-analyzing-ast")); 
		path' := <string-replace(|"\\", "/")>path;
		rules(
	      CachedParseAst: path' -> compilation-unit-ast
	  );
	  where ( <debug-compiler> $[Cache| storing currently analyzing AST in the cache with following key :  [<pp-aterm> path']] ) 


	
rules 
	
	get-all-modified-compilation-units = 	all-keys-modified-compilation-units
					