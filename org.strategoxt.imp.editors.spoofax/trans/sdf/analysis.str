module sdf/analysis
imports
  libstratego-sdf
  lib/editor-common.generated
	include/SpoofaxLang
imports
	  analysis
	  common
	  utils/debug
imports  
		context/sdf/declare-signature

rules
	
	analyze-sdf-ast:
		(ast, path, project-path) -> ast'
		with
				current-file := $[[project-path]/[path]];
      	rules(
        	IsImported  :  current-file
        )
        ;enable-sdf-debugging
        ;disable-sdf-debugging 
    where  
  		ast' := <declare-sdf-globals-top> ast
 
 strategies
	
	is-non-terminal =
    ?sort(_) + ?opt(_) + is-iter
  
  is-iter =
    ?iter(_) + ?iter-star(_) + ?iter-sep(_, _) + ?iter-star-sep(_, _)
			
rules      
	
	declare-sdf-globals-top =
    	alltd(declare-sdf-globals)
	
	//Ignores traversing STR sections  
	declare-sdf-globals: s@STRSection(_) -> s

	//Ignores traversing ESV sections 
	declare-sdf-globals: e@ESVSection(_) -> e

	declare-sdf-globals:
    prod @ prod(lhs, sort, _) -> <id>
    where
      x:= <get-rhs-sort-name>sort
   where
  		<store-operation-declaration>prod
    with
      <Declaration> x
    <+
      file := <CurrentFile>
      ;rules(
       	Declaration: x -> prod
        DeclarationFile: x -> file
  
        // Added following two dynamic rules for the ESV Def. analysis
        SortDeclaration:  x -> x
       	SortProductionLHS :+ x -> lhs
      )
    with
      <alltd(declare-sdf-use)> lhs
      
	declare-sdf-globals:
		lex-syntax@lexical-syntax(lex-defintions) ->lex-syntax
		with{|
					IsInsideLexicalSyntaxBlock:
						rules (IsInsideLexicalSyntaxBlock :_)
				 ;<declare-sdf-globals-top> lex-defintions
				|}  
				
	//TODO FIX : Unparameterized imports
	/*
	declare-sdf-globals:
		unparameterized(x) -> unparameterized(x)
    where
      <open-import(
        resolve-import
      , parse-spoofaxlang-file
      , declare-sdf-globals-top
      )> x
    <+
      rules(IsImportFailed: _)
	*/
	//TODO FIX : Import
	/*
	declare-sdf-globals:
		i@Import(Name(x)) -> i  
    where
      <open-import(
        resolve-import
      , parse-spoofaxlang-file
      , (store-definition(|<resolve-import>x);declare-sdf-globals-top)
      )> x
    <+
      rules(IsImportFailed: _)
	*/


  
	resolve-import =
    	// TODO: better import handling
		\x -> $[[<ProjectDir>]/[x].sdf]\; file-exists
  	<+
    	\x -> $[[<ProjectDir>]/syntax/[x].sdf]\; file-exists
  	<+
   		 \x -> $[[<ProjectDir>]/lib/[x].def]\; file-exists
  	<+
    	\x -> $[[<CurrentDir>]/[x].sdf]\; file-exists
  	<+
    	\x -> $[[<CurrentDir>]/[x].spx]\; file-exists
  	<+
  		\x -> $[[<ProjectDir>]/test/[x].spx]\; file-exists // TODO : temporarily adding this. will remove it later
 	
 	declare-sdf-globals:
		parameterized(x, y) -> parameterized(x, y)
  	where
			<declare-sdf-globals> unparameterized(x);
  		<alltd(declare-sdf-simple-global)> y
 
	declare-sdf-globals:
		'sorts(_) -> <id>
		with
    	 alltd(declare-sdf-use)
  
	declare-sdf-globals:
		context-free-start-symbols(_) -> <id>
		with
    	alltd(declare-sdf-use)
	  
  declare-sdf-globals:
		lexical-start-symbols(_) -> <id>
	  with
	  	alltd(declare-sdf-use)
	  
	declare-sdf-globals:
    kernel-start-symbols(_) -> <id>
    with
      alltd(declare-sdf-use)
	  
  /**
   *Creating Declaration Dynamic Rule for all the Sorts
   */
	declare-sdf-simple-global:
		sort(x) -> <id>
		with
	  	rules(Declaration: x -> x)
	    
	/**
	 *Creating Usage Dynamic Rule for all the sorts 
	 */
	declare-sdf-use:
    sort(x) -> <id>
    with
      rules(Usage: x -> x)
	  
	declare-sdf-use:
    parameterized-sort(x, y) -> <id>
    where
      if !y => [sort(y')]; <is-string> x; <is-string> y' then
        text := ${{x}[[{y'}]]};
        rules(Usage: text -> text)
      end
	  
	propose-completion:
    sort(COMPLETION(x)) -> [decl*, use*]
    with
      decl* := <all-keys-Declaration> x;
      use*  := <all-keys-Usage> x
	  
	propose-completion:
    NOCONTEXT(COMPLETION(x)) -> [decl*, use*]
    with
      decl* := <all-keys-Declaration> x;
      use*  := <all-keys-Usage> x
