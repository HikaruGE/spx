module sdf/to-signature

imports
	lib/editor-common.generated
imports 
	common
	analysis
imports 
	sdf/map-signatures
	sdf/analysis
	sdf/to-sdf

rules
	// Generate Signature for SDF Definition
	to-signature-all:
		(def, path , project-path) -> None()
		where  
			 	<debug> $[Spoofax-lang|Generating signature for the following package : [<Main-Package-Name>]]
			 	;rules (signature-file-name:=$[[<Main-Package-Name>].signature])
			 	;output-path-str 		:= <get-fullyqualified-autogen-path(|"str")>(project-path,<Autogenerated-Artifacts-Dir> , <signature-file-name>)
			 	;debug(!"output dir : ") 
			 	;output-path-rtree 	:= <get-fullyqualified-autogen-path(|"rtree")>(project-path,<Autogenerated-Artifacts-Dir> , <signature-file-name>)
			 	;generated-signatures :=  <get-signature-contents(|<signature-file-name>)><get-all-signatures-as-string> 
				;<dirname; ensure-directory-exists>output-path-str
				;<save-to-file>( output-path-str, generated-signatures) 
rules 
	//generate signature 
	get-signature-contents(|moduleName): signatures-string ->
$[module [moduleName]
signature
    constructors
       [signatures-string]
				
signature
    constructors
          Some : a -> Option(a) 
          None : Option(a)

signature
    constructors
          Cons : a * List(a) -> List(a)
          Nil  : List(a)
          Conc : List(a) * List(a) -> List(a)
]  
 
    	
	get-all-signatures-as-string 
  		= <mapconcat(bagof-Get-Operation-Declaration);operation-decl-to-string><all-keys-Get-Operation-Singature>
  
  operation-decl-to-string : [] -> $[]
  operation-decl-to-string : 
  	[first-op-decl | rest-op-decl* ] 
  		-> $[[current-op-decl-string] 
  			[rest-op-decl-string]]
  		where 
  			(opname, operands*, resultant-sort) := first-op-decl
  			;if (!operands* => []) then
  			 	current-op-decl-string := $[[<opname-to-string>opname]: [resultant-sort]]
  			else
  				current-op-decl-string := $[[<opname-to-string>opname]: [<lhs-operands-to-string>operands*] -> [resultant-sort]]
  			end		 
  			;rest-op-decl-string := <operation-decl-to-string> rest-op-decl* 
 	
 	opname-to-string : 
 		opname -> opname-string
 		where 
 				if (!opname => "") then 
 						opname-string := $[]
				else
					 opname-string  := opname
				end
				
  lhs-operands-to-string : 
		[] -> $[]
  lhs-operands-to-string : 
  	[last] -> $[[last]] 
  lhs-operands-to-string : 
  		[hd-operand|rest*] -> $[[hd-operand-string] * [rest-operand-string]]
  		where
  				not (![] => rest*) 
  		where 
  			  hd-operand-string := hd-operand 
  			  ;rest-operand-string := <lhs-operands-to-string>rest* 