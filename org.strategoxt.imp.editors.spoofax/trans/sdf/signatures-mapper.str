module sdf/signatures-mapper

imports 
		common 
		include/SpoofaxLang
		
imports 
		sdf/analysis


//TODO : refactor common functionily in seperate rules/strategy
strategies 
	get-rhs-sort-name = 
			try(?cf(<id>) + ?lex(<id>));
      repeat(?label(_, <id>));
      (?sort(<id>) + ?parameterized-sort(<id>, _))
		
rules 
	
	//Stores operation name and operation declarations 
	/**
  * Gets the operation name from the Production. It actually search all the attributes 
  * in the attribute list and create  a dynamic rule that stores operation name. 
  */
  get-opration-name = alltd(store-operation-name)
  
  
  /**
  *	Store operation name from the RHS of the Production, i.e. from fun constructors.
  * It creates a dynamic rule to store the operation name.
  */
  store-operation-name : f@fun(quoted( quoted-operation-name) ) -> f
  	with
  		opname := <un-double-quote>quoted-operation-name  
		;rules (get-op-name: _ -> opname)
  	where 
  		<debug-sdf> $[Operation Name :  [opname]]
	
	store-operation-declaration
  	=  ?p@prod(lhs , rhs-sort, attrs(attribute-list))
  		;rhs-sort-name := <get-rhs-sort-name>rhs-sort	
  		;{|lhs-sort, get-op-name:
  					<find-sorts>lhs
  					;<get-opration-name>attribute-list  
  					;operation-name := <get-op-name>
  					;lhs-operands-types := <reverse><bagof-lhs-sort>  
  					;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p) 
  		  |}
			  
	store-operation-declaration 
  	= 	?p@prod(lhs , rhs-sort, no-attrs()) 
  		;rhs-sort-name := <get-rhs-sort-name>rhs-sort	
  	  ; {|lhs-sort :
	  				if (IsInsideLexicalSyntaxBlock<+ (!rhs-sort; ?lex(sort(rhs-sort-name))))then 
							 rules ( lhs-sort :+ _ -> $[String] )
						else
							<find-sorts>lhs //TODO : consider ignorig :ID->ID-Prime operation decl 
						end
	  				;lhs-operands-types := <reverse><bagof-lhs-sort>
	  				;operation-name := ""
	  				;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)  
			 |}

	/*
	store-operation-declaration 
  	= ?p@prod(_ , lex(sort(rhs-sort-name)), no-attrs())
  		; {|lhs-sort :
							rules ( lhs-sort :+ _ -> $[String] )
		  				;lhs-operands-types := <reverse><bagof-lhs-sort>
		  				;operation-name := ""
		  				;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)  
			 |}
	*/
			 
  find-sorts 
  	= alltd(get-sort-decl)

rules  
	
	// Gets sort declaration from the production	
	get-sort-decl:
		a@alt(frstSort , restSort*) -> a
		where
			{| lhs-sort:
						<find-sorts>frstSort
					;	<find-sorts>restSort*
					;	inner-sort* := <bagof-lhs-sort;reverse>
					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort* 
			|}
			; <map(create-opname2opdecl-mapping(|"", intermediate-resultant-sort-type, "[N/A]" ))>inner-sort*	
			; rules( lhs-sort :+ _ -> intermediate-resultant-sort-type)
	
	get-sort-decl: 
		seq( frst , rest*)-> seq( frst , rest*)
		where
			{| lhs-sort:
						<find-sorts>frst
					;	<find-sorts>rest*
					;	inner-sort* := <bagof-lhs-sort;reverse>
					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort* 
					  
			|}
			; create-opname2opdecl-mapping(|"", inner-sort*, intermediate-resultant-sort-type, "[N/A]" ) 	
		 	; rules( lhs-sort :+ _ -> intermediate-resultant-sort-type)
	
	get-sort-decl: 
		i@iter-star ( x ) -> i
  	where 
  		{| 	lhs-sort:
  					<find-sorts>x
  				; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>
  		|}
  		;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")> inner-sorts-tostring])]
  		;rules ( lhs-sort :+ _ -> ret-string)
	
	
	get-sort-decl: 
		i@iter( x ) -> i
  	where 
  		{| lhs-sort:
  					<find-sorts>x
  				; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>
  		|}
  		;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")>inner-sorts-tostring])]
  		;rules ( lhs-sort :+ _ -> ret-string) 
			  
 	get-sort-decl:
 		p@parameterized-sort(x, _) ->p
		with 
			rules( lhs-sort :+ _ -> x)
			
  get-sort-decl: 
  	s@sort(x) -> s
  	with 
  		rules( lhs-sort :+ _ -> x)
	
	get-sort-decl: 
		o@opt(parameterized-sort(x, _)) -> o
  	with rules( lhs-sort :+ _ -> $[Option([x])])
  	
	get-sort-decl: 
		opt(sort(x)) -> opt(sort(x))
  	with rules( lhs-sort :+ _ -> $[Option([x])])
	
	get-sort-decl: 
		i@iter-star-sep(operand1, operand2) -> i
 		with {|lhs-sort:
			 					 <find-sorts>operand1
		 					  ;<find-sorts>operand2
		 					  ; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>    
				  |}
				 	;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")>inner-sorts-tostring])]
  				;rules ( lhs-sort :+ _ -> ret-string)	 
  				 
	get-sort-decl: 
		i@iter-sep(operand1, operand2) -> i
		with {|lhs-sort:
			 					 <find-sorts>operand1
		 					  ;<find-sorts>operand2
		 					  ;inner-sorts-tostring 
		 					   		:= <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>    
				  |}
				 	;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")>inner-sorts-tostring])]
  				;rules ( lhs-sort :+ _ -> ret-string)	 

		
strategies
		
	assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)= 
			?[hd|tl]
			;(expected-op-name , expected-op-sorts*, ex-resultant-sort) := hd
			;(
			 			 operation-name := expected-op-name 
						;opernand-sorts* := expected-op-sorts*
						;resultant-sort := ex-resultant-sort
				  <+
						<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>tl
				)	 
				
	/**
	* Create a dynamic rule that mapes operation name to the operation declaration.
	*	Addinationally, Arity of Operation Decl. has also been stored.
	* 
	* @Param operation-name.
	* @param Sort or Operand Types involve in the operation. 
	* @Param Resultant Sort from the operation .
	* @Param Production related to the operation.  
	*	
	*/		  
	create-opname2opdecl-mapping(|operation-name, opernand-sorts*, resultant-sort , production) =
		available-opdecl* := <bagof-Get-Operation-Declaration>operation-name  
		;if((!available-opdecl* => []) 
				<+ not (<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>available-opdecl*)
			)then 
					rules
				 		(
				 				Get-Operation-Singature:+ operation-name -> (operation-name , <length>opernand-sorts*)
				 				Get-Operation-Declaration :+ operation-name  -> (operation-name , opernand-sorts* , resultant-sort)
				 		)    
				 		; <debug-sdf> $[Stored operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm> ( operation-name , opernand-sorts* , resultant-sort) ].]
				 		; <debug-sdf> $[Stored operation signature: [<pp-aterm> operation-name] -> [<pp-aterm> (operation-name , <length>opernand-sorts*)].]  
 		 	else 
 		 			<debug-sdf> $[There is an existing operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm> ( operation-name , opernand-sorts* , resultant-sort) ].]
			end
	create-opname2opdecl-mapping(|operation-name, resultant-sort , production): alt-sort -> alt-sort  
		where 
			  alt-srt-lst := [alt-sort]
			  ;create-opname2opdecl-mapping(|operation-name, alt-srt-lst, resultant-sort , production)

