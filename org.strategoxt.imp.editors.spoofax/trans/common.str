module common

imports 
  libstratego-lib
  libstratego-sdf
  libstratego-sglr
  libstratego-gpp
  libstratego-aterm
  libstrc
  lib/editor-common.generated
  lib/sdf-desugar
  lib/sdf-parenthesize
imports 
	include/SpoofaxLang
	normalize/signatures
imports 
	utils/debug
	utils/path
	config
	editor/main

	
rules 
	get-project-path = (ProjectPath <+ project-path)

	package-qname-to-string : Package(untyped-qname) ->  <convert-qname(|".");string-replace(|"-", ".")> 	untyped-qname
	
strategies 
	//pretty printing aterm 
	pp-aterm = disable-pp-aterm < !"N/A" + pp-aterm-forced
	
	pp-aterm-forced = pp-aterm-box ; box2text-string(|100)

strategies
	/*internal*/ require(s) = not(s)

strategies 
	
	//After ensuring result is unique i.e. list contains only one element, it returns the unique result
	ensure-is-unique = ?[<id>] <+ where(<debug-symboltable>$[SymbolTable| Failed to resolve unique declaration.]);fail
	
	// Verifies that the current term is not a empty list 
	is-not-empty-list = ?[_|_] 
	
			
rules
 	
 	/**
 	* Creates a namespace reference table. It stores following in the reference table . 
 	* key : (package-name , concept-name) | value : def
 	*
 	*	@type a -> a 
 	*/
 	store-definition(|resolved-path): 
			def@definition -> def
			with
				(package-name, package-gen-relative-path)  := 	<find-spoofax-module-name-string>(resolved-path, def)
				;concept-name := <base-filename>package-name //TODO : get concept-name 
			with 
				if not(<is-declared>(package-name, concept-name)) then 
					rules
					( 
							DeclaredConcept :+ (package-name, concept-name ) -> def
							FilePath-of-DeclaredConcept:+ (package-name, concept-name ) -> resolved-path //TODO: not sure yet whether we need it.
							Package-Gen-Root-of-DeclaredConcept:+(package-name, concept-name )  -> package-gen-relative-path
					)
					  
					;<debug>$[SymbolTable|Storing following declaration - DeclaredConcept : ([package-name],[concept-name]) -> [<pp-aterm>def]]
				else
					<debug>$[ SymbolTable|Already exists in the namespace table : ([package-name],[concept-name])]	
				end 
	
	is-declared = get-declarations ; ?[_|_]
	
	get-declarations = ?(namespace, conceptname);bagof-DeclaredConcept
	
	get-unique-declaration = get-declarations; ?[<id>]
	  
	get-declarations-by-namespace= ?namespace ; get-all-declared-entries ; filter(?(namespace, _)); mapconcat(bagof-DeclaredConcept)
	
	get-all-declared-entries = all-keys-DeclaredConcept ; filter(?(_,_))
	
	get-all-declared-entries-by-namespace = ?namespace ; all-keys-DeclaredConcept ; filter(?(namespace,_))
	
	get-all-declared-concept = get-all-declared-entries ; filter(?(namespace, _)); mapconcat(bagof-DeclaredConcept)
	
	map-declarations(declaration-adapter): 
		list* -> result
		where 
			result :=<map(project-declaration(declaration-adapter))>list*
				
	project-declaration(declaration-adapter):
		n@(namespace, conceptname) -> result
 		where 
		 	concept := <get-unique-declaration> n
		  ;result := <declaration-adapter>(namespace,conceptname , concept)  
		
	project-allkeys-declared(adapter): 
		list* -> result
		where 
			result :=<map(project-key-declared(adapter))>list*
	
	project-key-declared (key-adapter):
		n@(namespace, conceptname) -> result
 		where 
		  result := <key-adapter>(namespace,conceptname)  
	
rules 
	
	find-spoofax-module-name:
    (path, def) -> name
   	 with
   	 		Module(name, _) := def
 	 		<+
   	 		if not(!path => "") then
      		name := <remove-extension> <base-filename> path
    		end
  
  
  //TODO : improve its performance by adding caching  		
 	find-spoofax-module-name-string: 
		(path,def) ->(package-name, relative-autogen-path)
	  with
				name := <find-spoofax-module-name> (path,def);
	      if !name => ParamName(n, p) then
	      	name' := parameterized(n, p)
      	else
   				(Name(name') := name) 
	      	<+ 
     			(name' := name) 
  	    end;
  	  	modname-part* := <string-tokenize> (['/'], name');
  	 		if <eq>(<length>modname-part* , 1) then
  	 		 		package-name  := name';
  	 		 		relative-autogen-path := ""
  	 		else
  	 		 	 package-name   := <last>modname-part*;
  	 		 	 relative-autogen-path := <dirname>name'  
  	 		end

rules	
  get-qualified-spxmodulename: 
  	(namespace-name,module-name) -> result
		where
			result := namespace-name//TODO : when there is a concept-name added in spx , result will be package-name/conceptname 
  
  //TODO : remove followind temp fix  
  get-qualified-importpath: 
  	(package-name,module-name) -> result
	where
		autogen-dir := <Package-Gen-Root-of-DeclaredConcept>(package-name,module-name)
		;<append-if-not-empty(|autogen-dir , "/")>package-name => result //TODO : when there is a module-name added in spx , result will be package-name/conceptname
	
 
  
  get-fullyqualified-autogen-path(|extension): 
  	(project-path, base-dir,spx-modulename) -> $[[project-path]/[base-dir]/[spx-modulename].[extension]]  
 
rules 
	save-to-file:(fileName, fileContent) -> None()  
  	where
    	not(<eq>("", fileContent))
    where
    	<debug-compiler> $[Writing to the following file : [fileName] the following content: 
      							[fileContent] 
    	]
    with
    	filedescr := <fopen> (fileName, "w+")
      ;<fputs>(fileContent , filedescr)
      ;<fclose>filedescr	
       
       
 rules // scoped renaming
	
	/**
	* executes the renaming strategy s in a new scope
	* 
	* declarations inside the new scope will hide existing declarations outside the new scope
	* multiple declarations with the same name inside the new scope will be renamed to the same name
	*
	* @param renaming strategy s: a -> b
	* @type a -> b
	*/
	new-scope(s) :
		x -> y
		where 
			<debug-compiler> $[Entering scope [<pp-aterm> x].]
		where
			<newname> x => scope ;
			{| Renamed, RenamedInScope, CurrentScope:
				rules (CurrentScope: _ -> scope) ;
				<s> x => y
			|} 
		where 
			<debug-compiler> $[Leaving scope [<pp-aterm> x].]
			
	/**
	* annotates the current term with a fresh name
	* can distinguish different namespaces
	* remembers the renaming by storing two dynamic rules
	* 
	* multiple calls on the same term inside the same scope will give identical results
	* calls inside a new scope will hide the results of calls to the same term from outer scopes
	*
	* @param namespace 
	* @type a -> a
	*/
	rename-declaration(|namespace) : 
		x -> x'
		where 
			CurrentScope => scope ;
			(
				<RenamedInScope> (namespace, scope, x) => x' <+
				x' := x{<newname> x}
			)
		where rules(
			RenamedInScope: (namespace, scope, x) -> x' 
			Renamed: (namespace, x) -> x'
		)
		where 
			<debug-compiler> $[Renamed declaration [<pp-aterm> x] to [<pp-aterm> x'] in namespace [<pp-aterm> namespace].]
	
	/**
	* annotates the current term with a new name
	* succeeds only if rename-declaration was called before on the same term
	* will use the same name as rename-declaration (by calling the dynamic rule stored by rename-declaration)
	*
	* @param namespace 
	* @type a -> b
	*/
	rename-reference(|namespace) :
			x -> x'
		where
			<Renamed> (namespace, x) => x'
		where 
			<debug-compiler> $[Renamed reference [<pp-aterm> x] to [<pp-aterm> x'] in namespace [<pp-aterm> namespace].]

 			 